{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Groundmeas Groundmeas is a toolkit for managing, analyzing, and visualizing grounding (earthing) measurements. It combines a SQLite data layer, a Python API, a CLI, a Streamlit dashboard, and physics-aware analytics for field work and reporting. What this guide covers Quickstart for CLI and Python workflows Data model for locations, measurements, and measurement items Step-by-step tutorials for creating, reading, editing, and importing data Analytics for impedance, touch voltages, split factor, and soil modeling Dashboard usage and plotting API and CLI reference Quick mental model You create a measurement with a method and optional location. You add measurement items (impedance, current, voltage, soil resistivity) with metadata. Analytics functions read items from the database and compute results. Plot helpers and the dashboard visualize those results. Physical background Earthing impedance relates Earth Potential Rise to injected current. \\[ Z_E(f) = \\frac{V_{EPR}(f)}{I_E(f)} \\] Earth Potential Rise is computed from impedance and current. \\[ EPR = Z_E \\cdot I_E \\] The rho-f model links impedance to soil resistivity and frequency. \\[ Z(\\rho, f) = k_1 \\cdot \\rho + (k_2 + j k_3) \\cdot f + (k_4 + j k_5) \\cdot \\rho \\cdot f \\] Soil resistivity surveys use Wenner or Schlumberger arrays and feed the multilayer soil model used later in analytics. Navigation Quickstart: 02_quickstart.md Tutorials: 10_tutorial_intro.md and the tutorial series Reference: 20_ref_intro.md , 21_ref_api.md , 22_ref_cli.md","title":"Groundmeas"},{"location":"#groundmeas","text":"Groundmeas is a toolkit for managing, analyzing, and visualizing grounding (earthing) measurements. It combines a SQLite data layer, a Python API, a CLI, a Streamlit dashboard, and physics-aware analytics for field work and reporting.","title":"Groundmeas"},{"location":"#what-this-guide-covers","text":"Quickstart for CLI and Python workflows Data model for locations, measurements, and measurement items Step-by-step tutorials for creating, reading, editing, and importing data Analytics for impedance, touch voltages, split factor, and soil modeling Dashboard usage and plotting API and CLI reference","title":"What this guide covers"},{"location":"#quick-mental-model","text":"You create a measurement with a method and optional location. You add measurement items (impedance, current, voltage, soil resistivity) with metadata. Analytics functions read items from the database and compute results. Plot helpers and the dashboard visualize those results.","title":"Quick mental model"},{"location":"#physical-background","text":"Earthing impedance relates Earth Potential Rise to injected current. \\[ Z_E(f) = \\frac{V_{EPR}(f)}{I_E(f)} \\] Earth Potential Rise is computed from impedance and current. \\[ EPR = Z_E \\cdot I_E \\] The rho-f model links impedance to soil resistivity and frequency. \\[ Z(\\rho, f) = k_1 \\cdot \\rho + (k_2 + j k_3) \\cdot f + (k_4 + j k_5) \\cdot \\rho \\cdot f \\] Soil resistivity surveys use Wenner or Schlumberger arrays and feed the multilayer soil model used later in analytics.","title":"Physical background"},{"location":"#navigation","text":"Quickstart: 02_quickstart.md Tutorials: 10_tutorial_intro.md and the tutorial series Reference: 20_ref_intro.md , 21_ref_api.md , 22_ref_cli.md","title":"Navigation"},{"location":"00_index/","text":"Groundmeas Groundmeas is a toolkit for managing, analyzing, and visualizing grounding (earthing) measurements. It combines a SQLite data layer, a Python API, a CLI, a Streamlit dashboard, and physics-aware analytics for field work and reporting. What this guide covers Quickstart for CLI and Python workflows Data model for locations, measurements, and measurement items Step-by-step tutorials for creating, reading, editing, and importing data Analytics for impedance, touch voltages, split factor, and soil modeling Dashboard usage and plotting API and CLI reference Quick mental model You create a measurement with a method and optional location. You add measurement items (impedance, current, voltage, soil resistivity) with metadata. Analytics functions read items from the database and compute results. Plot helpers and the dashboard visualize those results. Physical background Earthing impedance relates Earth Potential Rise to injected current. \\[ Z_E(f) = \\frac{V_{EPR}(f)}{I_E(f)} \\] Earth Potential Rise is computed from impedance and current. \\[ EPR = Z_E \\cdot I_E \\] The rho-f model links impedance to soil resistivity and frequency. \\[ Z(\\rho, f) = k_1 \\cdot \\rho + (k_2 + j k_3) \\cdot f + (k_4 + j k_5) \\cdot \\rho \\cdot f \\] Soil resistivity surveys use Wenner or Schlumberger arrays and feed the multilayer soil model used later in analytics. Navigation Quickstart: 02_quickstart.md Tutorials: 10_tutorial_intro.md and the tutorial series Reference: 20_ref_intro.md , 21_ref_api.md , 22_ref_cli.md","title":"Home"},{"location":"00_index/#groundmeas","text":"Groundmeas is a toolkit for managing, analyzing, and visualizing grounding (earthing) measurements. It combines a SQLite data layer, a Python API, a CLI, a Streamlit dashboard, and physics-aware analytics for field work and reporting.","title":"Groundmeas"},{"location":"00_index/#what-this-guide-covers","text":"Quickstart for CLI and Python workflows Data model for locations, measurements, and measurement items Step-by-step tutorials for creating, reading, editing, and importing data Analytics for impedance, touch voltages, split factor, and soil modeling Dashboard usage and plotting API and CLI reference","title":"What this guide covers"},{"location":"00_index/#quick-mental-model","text":"You create a measurement with a method and optional location. You add measurement items (impedance, current, voltage, soil resistivity) with metadata. Analytics functions read items from the database and compute results. Plot helpers and the dashboard visualize those results.","title":"Quick mental model"},{"location":"00_index/#physical-background","text":"Earthing impedance relates Earth Potential Rise to injected current. \\[ Z_E(f) = \\frac{V_{EPR}(f)}{I_E(f)} \\] Earth Potential Rise is computed from impedance and current. \\[ EPR = Z_E \\cdot I_E \\] The rho-f model links impedance to soil resistivity and frequency. \\[ Z(\\rho, f) = k_1 \\cdot \\rho + (k_2 + j k_3) \\cdot f + (k_4 + j k_5) \\cdot \\rho \\cdot f \\] Soil resistivity surveys use Wenner or Schlumberger arrays and feed the multilayer soil model used later in analytics.","title":"Physical background"},{"location":"00_index/#navigation","text":"Quickstart: 02_quickstart.md Tutorials: 10_tutorial_intro.md and the tutorial series Reference: 20_ref_intro.md , 21_ref_api.md , 22_ref_cli.md","title":"Navigation"},{"location":"01_datamodels/","text":"Data models Groundmeas stores data in SQLite via SQLModel with three core entities: Location, Measurement, and MeasurementItem. Location Fields: - id (int, primary key) - name (str) - latitude , longitude , altitude (float, optional) - Back-reference: measurements Measurement Fields: - id (int, primary key) - timestamp (UTC, auto) - location_id / location (optional) - method : staged_fault_test , injection_remote_substation , injection_earth_electrode , wenner , schlumberger - asset_type : substation , overhead_line_tower , cable , cable_cabinet , house , pole_mounted_transformer , mv_lv_earthing_system - voltage_level_kv , fault_resistance_ohm (optional) - operator , description (optional) - items : list of MeasurementItem MeasurementItem Supports polar or rectangular representation. The model enforces consistency with an event hook. Fields: - id (int, primary key) - measurement_id / measurement (FK to Measurement ) - measurement_type : - Voltages: prospective_touch_voltage , touch_voltage , earth_potential_rise , step_voltage , transferred_potential - Currents: earth_fault_current , earthing_current , shield_current - Impedance and resistance: earthing_impedance , earthing_resistance - Soil: soil_resistivity - Value fields (polar): value , value_angle_deg - Value fields (rectangular): value_real , value_imag - Metadata: unit , frequency_hz , measurement_distance_m , distance_to_current_injection_m , additional_resistance_ohm , input_impedance_ohm , description Soil resistivity data conventions Wenner: store spacing a in measurement_distance_m . Schlumberger: by default store AB/2 in measurement_distance_m and MN/2 in distance_to_current_injection_m . If you store full AB or full MN, set ab_is_full=True or mn_is_full=True in analytics and CLI. If the stored value is resistivity, use a unit like ohm-m . If the stored value is resistance, use a unit like ohm and set value_kind=\"resistance\" when analyzing. Consistency rules If only value_real and value_imag are provided, magnitude and angle are computed automatically. If value and value_angle_deg are provided, real and imag parts are computed. At least one representation must be present or insertion raises ValueError . Relationships and usage A Measurement can exist without a Location , but most workflows create both. Items are always attached to a Measurement . The CLI and API mirror this structure: create a measurement, then create items.","title":"Data Model"},{"location":"01_datamodels/#data-models","text":"Groundmeas stores data in SQLite via SQLModel with three core entities: Location, Measurement, and MeasurementItem.","title":"Data models"},{"location":"01_datamodels/#location","text":"Fields: - id (int, primary key) - name (str) - latitude , longitude , altitude (float, optional) - Back-reference: measurements","title":"Location"},{"location":"01_datamodels/#measurement","text":"Fields: - id (int, primary key) - timestamp (UTC, auto) - location_id / location (optional) - method : staged_fault_test , injection_remote_substation , injection_earth_electrode , wenner , schlumberger - asset_type : substation , overhead_line_tower , cable , cable_cabinet , house , pole_mounted_transformer , mv_lv_earthing_system - voltage_level_kv , fault_resistance_ohm (optional) - operator , description (optional) - items : list of MeasurementItem","title":"Measurement"},{"location":"01_datamodels/#measurementitem","text":"Supports polar or rectangular representation. The model enforces consistency with an event hook. Fields: - id (int, primary key) - measurement_id / measurement (FK to Measurement ) - measurement_type : - Voltages: prospective_touch_voltage , touch_voltage , earth_potential_rise , step_voltage , transferred_potential - Currents: earth_fault_current , earthing_current , shield_current - Impedance and resistance: earthing_impedance , earthing_resistance - Soil: soil_resistivity - Value fields (polar): value , value_angle_deg - Value fields (rectangular): value_real , value_imag - Metadata: unit , frequency_hz , measurement_distance_m , distance_to_current_injection_m , additional_resistance_ohm , input_impedance_ohm , description","title":"MeasurementItem"},{"location":"01_datamodels/#soil-resistivity-data-conventions","text":"Wenner: store spacing a in measurement_distance_m . Schlumberger: by default store AB/2 in measurement_distance_m and MN/2 in distance_to_current_injection_m . If you store full AB or full MN, set ab_is_full=True or mn_is_full=True in analytics and CLI. If the stored value is resistivity, use a unit like ohm-m . If the stored value is resistance, use a unit like ohm and set value_kind=\"resistance\" when analyzing.","title":"Soil resistivity data conventions"},{"location":"01_datamodels/#consistency-rules","text":"If only value_real and value_imag are provided, magnitude and angle are computed automatically. If value and value_angle_deg are provided, real and imag parts are computed. At least one representation must be present or insertion raises ValueError .","title":"Consistency rules"},{"location":"01_datamodels/#relationships-and-usage","text":"A Measurement can exist without a Location , but most workflows create both. Items are always attached to a Measurement . The CLI and API mirror this structure: create a measurement, then create items.","title":"Relationships and usage"},{"location":"02_quickstart/","text":"Quickstart (CLI and Python) Goal: create a database, add a measurement with impedance items, run a basic distance-profile analysis, and then run a small soil resistivity survey with a layered-earth inversion. CLI route # 1) Create or connect to a database (auto-created) gm-cli --db ./groundmeas.db list-measurements # 2) Add a measurement interactively (location, method, asset, and metadata) gm-cli --db ./groundmeas.db add-measurement # 3) Add items interactively (repeat for each distance) gm-cli --db ./groundmeas.db add-item MEAS_ID # 4) Read items back gm-cli --db ./groundmeas.db list-items MEAS_ID # 5) Run two distance-profile algorithms gm-cli --db ./groundmeas.db distance-profile MEAS_ID --type earthing_impedance --algorithm maximum gm-cli --db ./groundmeas.db distance-profile MEAS_ID --type earthing_impedance --algorithm minimum_gradient # 6) Plot impedance vs distance (static) gm-cli --db ./groundmeas.db plot-impedance MEAS_ID --out plots/impedance.png Optional soil survey flow: # 7) Create a soil survey measurement (method wenner or schlumberger) gm-cli --db ./groundmeas.db add-measurement # 8) Add soil_resistivity items (spacing in measurement_distance_m) # Use add-item for each spacing in your survey gm-cli --db ./groundmeas.db add-item SOIL_MEAS_ID # 9) Build a depth-resistivity profile # Wenner default uses spacing as a; Schlumberger defaults to AB/2 and MN/2 gm-cli --db ./groundmeas.db soil-profile SOIL_MEAS_ID --method wenner # 10) Invert a 1-3 layer model gm-cli --db ./groundmeas.db soil-inversion SOIL_MEAS_ID --layers 2 --method wenner # 11) Plot the inversion fit gm-cli --db ./groundmeas.db plot-soil-inversion SOIL_MEAS_ID --layers 2 --out plots/soil_inversion.png Python route from groundmeas.db import connect_db , create_measurement , create_item , read_items_by from groundmeas.analytics import distance_profile_value from groundmeas.plots import plot_value_over_distance connect_db ( \"groundmeas.db\" ) # 1) Create a staged fault test measurement mid = create_measurement ({ \"method\" : \"staged_fault_test\" , \"asset_type\" : \"substation\" , \"voltage_level_kv\" : 10.0 , \"fault_resistance_ohm\" : 1.0 , \"description\" : \"Quickstart example\" , \"location\" : { \"name\" : \"Site A\" , \"latitude\" : 51.0 , \"longitude\" : 10.0 } }) # 2) Add impedance items at multiple distances for idx , dist in enumerate ( range ( 10 , 110 , 10 )): create_item ({ \"measurement_type\" : \"earthing_impedance\" , \"frequency_hz\" : 50.0 , \"value\" : 0.3 + 0.02 * idx , \"value_angle_deg\" : 0.0 , \"unit\" : \"ohm\" , \"measurement_distance_m\" : float ( dist ), \"distance_to_current_injection_m\" : 150.0 , }, measurement_id = mid ) # 3) Analyze distance profile res = distance_profile_value ( mid , algorithm = \"minimum_gradient\" ) print ( res [ \"result_value\" ], res [ \"result_distance_m\" ]) # 4) Plot impedance vs distance fig = plot_value_over_distance ( mid , measurement_type = \"earthing_impedance\" ) fig . savefig ( \"plots/impedance_distance.png\" ) Optional soil survey (Python): from groundmeas.analytics import soil_resistivity_profile , invert_soil_resistivity_layers soil_id = create_measurement ({ \"method\" : \"wenner\" , \"asset_type\" : \"substation\" , \"description\" : \"Wenner soil survey\" , \"location\" : { \"name\" : \"Site A\" } }) spacings = [ 1.0 , 2.0 , 4.0 , 8.0 , 16.0 ] values = [ 80.0 , 75.0 , 65.0 , 55.0 , 50.0 ] for spacing , rho_a in zip ( spacings , values ): create_item ({ \"measurement_type\" : \"soil_resistivity\" , \"value\" : rho_a , \"unit\" : \"ohm-m\" , \"measurement_distance_m\" : spacing , }, measurement_id = soil_id ) profile = soil_resistivity_profile ( soil_id , method = \"wenner\" ) print ( profile [: 3 ]) inv = invert_soil_resistivity_layers ( soil_id , method = \"wenner\" , layers = 2 ) print ( inv [ \"rho_layers\" ], inv [ \"thicknesses_m\" ]) Next steps: follow the tutorials for realistic, field-level workflows and check the reference pages for full inputs and outputs.","title":"Quickstart"},{"location":"02_quickstart/#quickstart-cli-and-python","text":"Goal: create a database, add a measurement with impedance items, run a basic distance-profile analysis, and then run a small soil resistivity survey with a layered-earth inversion.","title":"Quickstart (CLI and Python)"},{"location":"02_quickstart/#cli-route","text":"# 1) Create or connect to a database (auto-created) gm-cli --db ./groundmeas.db list-measurements # 2) Add a measurement interactively (location, method, asset, and metadata) gm-cli --db ./groundmeas.db add-measurement # 3) Add items interactively (repeat for each distance) gm-cli --db ./groundmeas.db add-item MEAS_ID # 4) Read items back gm-cli --db ./groundmeas.db list-items MEAS_ID # 5) Run two distance-profile algorithms gm-cli --db ./groundmeas.db distance-profile MEAS_ID --type earthing_impedance --algorithm maximum gm-cli --db ./groundmeas.db distance-profile MEAS_ID --type earthing_impedance --algorithm minimum_gradient # 6) Plot impedance vs distance (static) gm-cli --db ./groundmeas.db plot-impedance MEAS_ID --out plots/impedance.png Optional soil survey flow: # 7) Create a soil survey measurement (method wenner or schlumberger) gm-cli --db ./groundmeas.db add-measurement # 8) Add soil_resistivity items (spacing in measurement_distance_m) # Use add-item for each spacing in your survey gm-cli --db ./groundmeas.db add-item SOIL_MEAS_ID # 9) Build a depth-resistivity profile # Wenner default uses spacing as a; Schlumberger defaults to AB/2 and MN/2 gm-cli --db ./groundmeas.db soil-profile SOIL_MEAS_ID --method wenner # 10) Invert a 1-3 layer model gm-cli --db ./groundmeas.db soil-inversion SOIL_MEAS_ID --layers 2 --method wenner # 11) Plot the inversion fit gm-cli --db ./groundmeas.db plot-soil-inversion SOIL_MEAS_ID --layers 2 --out plots/soil_inversion.png","title":"CLI route"},{"location":"02_quickstart/#python-route","text":"from groundmeas.db import connect_db , create_measurement , create_item , read_items_by from groundmeas.analytics import distance_profile_value from groundmeas.plots import plot_value_over_distance connect_db ( \"groundmeas.db\" ) # 1) Create a staged fault test measurement mid = create_measurement ({ \"method\" : \"staged_fault_test\" , \"asset_type\" : \"substation\" , \"voltage_level_kv\" : 10.0 , \"fault_resistance_ohm\" : 1.0 , \"description\" : \"Quickstart example\" , \"location\" : { \"name\" : \"Site A\" , \"latitude\" : 51.0 , \"longitude\" : 10.0 } }) # 2) Add impedance items at multiple distances for idx , dist in enumerate ( range ( 10 , 110 , 10 )): create_item ({ \"measurement_type\" : \"earthing_impedance\" , \"frequency_hz\" : 50.0 , \"value\" : 0.3 + 0.02 * idx , \"value_angle_deg\" : 0.0 , \"unit\" : \"ohm\" , \"measurement_distance_m\" : float ( dist ), \"distance_to_current_injection_m\" : 150.0 , }, measurement_id = mid ) # 3) Analyze distance profile res = distance_profile_value ( mid , algorithm = \"minimum_gradient\" ) print ( res [ \"result_value\" ], res [ \"result_distance_m\" ]) # 4) Plot impedance vs distance fig = plot_value_over_distance ( mid , measurement_type = \"earthing_impedance\" ) fig . savefig ( \"plots/impedance_distance.png\" ) Optional soil survey (Python): from groundmeas.analytics import soil_resistivity_profile , invert_soil_resistivity_layers soil_id = create_measurement ({ \"method\" : \"wenner\" , \"asset_type\" : \"substation\" , \"description\" : \"Wenner soil survey\" , \"location\" : { \"name\" : \"Site A\" } }) spacings = [ 1.0 , 2.0 , 4.0 , 8.0 , 16.0 ] values = [ 80.0 , 75.0 , 65.0 , 55.0 , 50.0 ] for spacing , rho_a in zip ( spacings , values ): create_item ({ \"measurement_type\" : \"soil_resistivity\" , \"value\" : rho_a , \"unit\" : \"ohm-m\" , \"measurement_distance_m\" : spacing , }, measurement_id = soil_id ) profile = soil_resistivity_profile ( soil_id , method = \"wenner\" ) print ( profile [: 3 ]) inv = invert_soil_resistivity_layers ( soil_id , method = \"wenner\" , layers = 2 ) print ( inv [ \"rho_layers\" ], inv [ \"thicknesses_m\" ]) Next steps: follow the tutorials for realistic, field-level workflows and check the reference pages for full inputs and outputs.","title":"Python route"},{"location":"10_tutorial_intro/","text":"Tutorials overview This tutorial series covers two primary workflows: staged fault testing and soil resistivity surveying. Each tutorial includes physical context, a step-by-step workflow, Python API and CLI examples, and practical notes. Physical background Earthing impedance relates Earth Potential Rise to injected current. \\[ Z_E(f) = \\frac{V_{EPR}(f)}{I_E(f)} \\] Soil resistivity surveys use Wenner or Schlumberger arrays. Apparent resistivity for Wenner is: \\[ \\rho_a = 2 \\pi a R \\] Function overview Database and CRUD: connect_db , create_measurement , create_item , read_items_by . Impedance analytics: distance_profile_value , impedance_over_frequency . Soil analytics: soil_resistivity_profile , invert_soil_resistivity_layers . Inputs and outputs Function Input Output Description connect_db path none Initialize the database connection. create_measurement measurement dict measurement id Create a measurement record. create_item item dict, measurement_id item id Create a measurement item. distance_profile_value measurement id, algorithm dict Reduce a distance profile to one value. soil_resistivity_profile measurement id, method dict Map depth to apparent resistivity. invert_soil_resistivity_layers measurement id, layers dict Fit a layered soil model. General workflow Scenario A: staged fault test Create a measurement with method staged_fault_test and location. Add impedance items with distance and frequency. Add shield current and fault current items if available. Verify data and run distance-profile analytics. Scenario B: soil resistivity survey Create a measurement with method wenner or schlumberger . Add soil resistivity items for each spacing. Build a depth-resistivity profile. Invert a 1 to 3 layer model. Python API examples Scenario A: staged fault test from groundmeas.db import connect_db , create_measurement , create_item from groundmeas.analytics import distance_profile_value connect_db ( \"groundmeas.db\" ) mid = create_measurement ({ \"method\" : \"staged_fault_test\" , \"asset_type\" : \"substation\" , \"description\" : \"Staged fault test\" , \"location\" : { \"name\" : \"Site A\" }, }) for dist , val in [( 10 , 0.40 ), ( 30 , 0.36 ), ( 50 , 0.34 )]: create_item ({ \"measurement_type\" : \"earthing_impedance\" , \"frequency_hz\" : 50.0 , \"value\" : val , \"value_angle_deg\" : 0.0 , \"unit\" : \"ohm\" , \"measurement_distance_m\" : float ( dist ), \"distance_to_current_injection_m\" : 200.0 , }, measurement_id = mid ) result = distance_profile_value ( mid , algorithm = \"minimum_gradient\" ) print ( result [ \"result_value\" ], result [ \"result_distance_m\" ]) Scenario B: soil survey from groundmeas.db import connect_db , create_measurement , create_item from groundmeas.analytics import soil_resistivity_profile , invert_soil_resistivity_layers connect_db ( \"groundmeas.db\" ) soil_id = create_measurement ({ \"method\" : \"wenner\" , \"asset_type\" : \"substation\" , \"description\" : \"Wenner survey\" , \"location\" : { \"name\" : \"Site A\" }, }) for spacing , rho_a in [( 1.0 , 80.0 ), ( 2.0 , 70.0 ), ( 4.0 , 55.0 )]: create_item ({ \"measurement_type\" : \"soil_resistivity\" , \"value\" : rho_a , \"unit\" : \"ohm-m\" , \"measurement_distance_m\" : spacing , }, measurement_id = soil_id ) profile = soil_resistivity_profile ( soil_id , method = \"wenner\" ) print ( profile ) inv = invert_soil_resistivity_layers ( soil_id , method = \"wenner\" , layers = 2 ) print ( inv [ \"rho_layers\" ], inv [ \"thicknesses_m\" ]) CLI examples Scenario A: staged fault test gm-cli add-measurement gm-cli add-item MEAS_ID gm-cli distance-profile MEAS_ID --type earthing_impedance --algorithm minimum_gradient Scenario B: soil survey gm-cli add-measurement gm-cli add-item SOIL_MEAS_ID gm-cli soil-profile SOIL_MEAS_ID --method wenner gm-cli soil-inversion SOIL_MEAS_ID --layers 2 --method wenner Additional notes Missing measurement_distance_m prevents distance-based analytics. Schlumberger spacing defaults to AB/2 and MN/2; set ab_is_full or mn_is_full if you store full spacings. Use JSON export as a backup before editing or deleting data. For algorithm selection and behavior details, see the Distance profile reduction section.","title":"Overview"},{"location":"10_tutorial_intro/#tutorials-overview","text":"This tutorial series covers two primary workflows: staged fault testing and soil resistivity surveying. Each tutorial includes physical context, a step-by-step workflow, Python API and CLI examples, and practical notes.","title":"Tutorials overview"},{"location":"10_tutorial_intro/#physical-background","text":"Earthing impedance relates Earth Potential Rise to injected current. \\[ Z_E(f) = \\frac{V_{EPR}(f)}{I_E(f)} \\] Soil resistivity surveys use Wenner or Schlumberger arrays. Apparent resistivity for Wenner is: \\[ \\rho_a = 2 \\pi a R \\]","title":"Physical background"},{"location":"10_tutorial_intro/#function-overview","text":"Database and CRUD: connect_db , create_measurement , create_item , read_items_by . Impedance analytics: distance_profile_value , impedance_over_frequency . Soil analytics: soil_resistivity_profile , invert_soil_resistivity_layers .","title":"Function overview"},{"location":"10_tutorial_intro/#inputs-and-outputs","text":"Function Input Output Description connect_db path none Initialize the database connection. create_measurement measurement dict measurement id Create a measurement record. create_item item dict, measurement_id item id Create a measurement item. distance_profile_value measurement id, algorithm dict Reduce a distance profile to one value. soil_resistivity_profile measurement id, method dict Map depth to apparent resistivity. invert_soil_resistivity_layers measurement id, layers dict Fit a layered soil model.","title":"Inputs and outputs"},{"location":"10_tutorial_intro/#general-workflow","text":"","title":"General workflow"},{"location":"10_tutorial_intro/#scenario-a-staged-fault-test","text":"Create a measurement with method staged_fault_test and location. Add impedance items with distance and frequency. Add shield current and fault current items if available. Verify data and run distance-profile analytics.","title":"Scenario A: staged fault test"},{"location":"10_tutorial_intro/#scenario-b-soil-resistivity-survey","text":"Create a measurement with method wenner or schlumberger . Add soil resistivity items for each spacing. Build a depth-resistivity profile. Invert a 1 to 3 layer model.","title":"Scenario B: soil resistivity survey"},{"location":"10_tutorial_intro/#python-api-examples","text":"","title":"Python API examples"},{"location":"10_tutorial_intro/#scenario-a-staged-fault-test_1","text":"from groundmeas.db import connect_db , create_measurement , create_item from groundmeas.analytics import distance_profile_value connect_db ( \"groundmeas.db\" ) mid = create_measurement ({ \"method\" : \"staged_fault_test\" , \"asset_type\" : \"substation\" , \"description\" : \"Staged fault test\" , \"location\" : { \"name\" : \"Site A\" }, }) for dist , val in [( 10 , 0.40 ), ( 30 , 0.36 ), ( 50 , 0.34 )]: create_item ({ \"measurement_type\" : \"earthing_impedance\" , \"frequency_hz\" : 50.0 , \"value\" : val , \"value_angle_deg\" : 0.0 , \"unit\" : \"ohm\" , \"measurement_distance_m\" : float ( dist ), \"distance_to_current_injection_m\" : 200.0 , }, measurement_id = mid ) result = distance_profile_value ( mid , algorithm = \"minimum_gradient\" ) print ( result [ \"result_value\" ], result [ \"result_distance_m\" ])","title":"Scenario A: staged fault test"},{"location":"10_tutorial_intro/#scenario-b-soil-survey","text":"from groundmeas.db import connect_db , create_measurement , create_item from groundmeas.analytics import soil_resistivity_profile , invert_soil_resistivity_layers connect_db ( \"groundmeas.db\" ) soil_id = create_measurement ({ \"method\" : \"wenner\" , \"asset_type\" : \"substation\" , \"description\" : \"Wenner survey\" , \"location\" : { \"name\" : \"Site A\" }, }) for spacing , rho_a in [( 1.0 , 80.0 ), ( 2.0 , 70.0 ), ( 4.0 , 55.0 )]: create_item ({ \"measurement_type\" : \"soil_resistivity\" , \"value\" : rho_a , \"unit\" : \"ohm-m\" , \"measurement_distance_m\" : spacing , }, measurement_id = soil_id ) profile = soil_resistivity_profile ( soil_id , method = \"wenner\" ) print ( profile ) inv = invert_soil_resistivity_layers ( soil_id , method = \"wenner\" , layers = 2 ) print ( inv [ \"rho_layers\" ], inv [ \"thicknesses_m\" ])","title":"Scenario B: soil survey"},{"location":"10_tutorial_intro/#cli-examples","text":"","title":"CLI examples"},{"location":"10_tutorial_intro/#scenario-a-staged-fault-test_2","text":"gm-cli add-measurement gm-cli add-item MEAS_ID gm-cli distance-profile MEAS_ID --type earthing_impedance --algorithm minimum_gradient","title":"Scenario A: staged fault test"},{"location":"10_tutorial_intro/#scenario-b-soil-survey_1","text":"gm-cli add-measurement gm-cli add-item SOIL_MEAS_ID gm-cli soil-profile SOIL_MEAS_ID --method wenner gm-cli soil-inversion SOIL_MEAS_ID --layers 2 --method wenner","title":"Scenario B: soil survey"},{"location":"10_tutorial_intro/#additional-notes","text":"Missing measurement_distance_m prevents distance-based analytics. Schlumberger spacing defaults to AB/2 and MN/2; set ab_is_full or mn_is_full if you store full spacings. Use JSON export as a backup before editing or deleting data. For algorithm selection and behavior details, see the Distance profile reduction section.","title":"Additional notes"},{"location":"11_create_measurements/","text":"Create measurements This tutorial covers how to create measurements for two real-world scenarios: a staged fault test and a soil resistivity survey. Physical background Earthing impedance relates Earth Potential Rise to injected current. \\[ Z_E(f) = \\frac{V_{EPR}(f)}{I_E(f)} \\] Soil resistivity surveys estimate apparent resistivity. Wenner array formula: \\[ \\rho_a = 2 \\pi a R \\] Schlumberger array formula: \\[ \\rho_a = \\pi \\frac{AB^2 - MN^2}{4 MN} R \\] Function overview create_measurement creates a measurement record. create_item stores impedance, current, voltage, or soil resistivity items. read_items_by helps verify inserted items. Inputs and outputs Function Input Output Description create_measurement measurement dict measurement id Create a measurement with optional location. create_item item dict, measurement_id item id Create an item linked to a measurement. read_items_by filters list of items Read items for verification. General workflow Scenario A: staged fault test Create a measurement with method staged_fault_test and location metadata. Add earthing_impedance items for each distance. Add shield_current or earth_fault_current if available. Verify item count and distances. Scenario B: soil resistivity survey Create a measurement with method wenner or schlumberger . Add soil_resistivity items at each spacing. Store spacing in measurement_distance_m . Store MN spacing in distance_to_current_injection_m for Schlumberger if needed. Python API examples Scenario A: staged fault test from groundmeas.db import connect_db , create_measurement , create_item , read_items_by connect_db ( \"groundmeas.db\" ) mid = create_measurement ({ \"method\" : \"staged_fault_test\" , \"asset_type\" : \"substation\" , \"voltage_level_kv\" : 20.0 , \"fault_resistance_ohm\" : 1.0 , \"description\" : \"Staged fault test\" , \"location\" : { \"name\" : \"Substation West\" }, }) for dist , value in [( 10 , 0.40 ), ( 30 , 0.36 ), ( 50 , 0.34 )]: create_item ({ \"measurement_type\" : \"earthing_impedance\" , \"frequency_hz\" : 50.0 , \"value\" : value , \"value_angle_deg\" : 0.0 , \"unit\" : \"ohm\" , \"measurement_distance_m\" : float ( dist ), \"distance_to_current_injection_m\" : 200.0 , }, measurement_id = mid ) create_item ({ \"measurement_type\" : \"shield_current\" , \"frequency_hz\" : 50.0 , \"value\" : 45.0 , \"value_angle_deg\" : - 10.0 , \"unit\" : \"A\" , }, measurement_id = mid ) items , _ = read_items_by ( measurement_id = mid ) print ( len ( items )) Scenario B: soil resistivity survey from groundmeas.db import connect_db , create_measurement , create_item connect_db ( \"groundmeas.db\" ) soil_id = create_measurement ({ \"method\" : \"schlumberger\" , \"asset_type\" : \"substation\" , \"description\" : \"Schlumberger survey\" , \"location\" : { \"name\" : \"Substation West\" }, }) # Store AB/2 in measurement_distance_m, MN/2 in distance_to_current_injection_m for ab2 , mn2 , r in [( 1.0 , 0.5 , 12.0 ), ( 2.0 , 0.5 , 10.5 ), ( 4.0 , 0.5 , 9.0 )]: create_item ({ \"measurement_type\" : \"soil_resistivity\" , \"value\" : r , \"unit\" : \"ohm\" , \"measurement_distance_m\" : ab2 , \"distance_to_current_injection_m\" : mn2 , }, measurement_id = soil_id ) CLI examples Scenario A: staged fault test gm-cli add-measurement # Add impedance points for d in 10 30 50 ; do gm-cli add-item MEAS_ID # choose earthing_impedance, set frequency 50, value, and distance $d # set distance_to_current_injection_m to 200 done gm-cli add-item MEAS_ID # choose shield_current and enter value Scenario B: soil resistivity survey gm-cli add-measurement # Add soil resistivity items for each spacing for a in 1 2 4 ; do gm-cli add-item SOIL_MEAS_ID # choose soil_resistivity, set value, and spacing $a done Additional notes Use consistent units (ohm, ohm-m) across a survey. For Schlumberger, confirm whether you store full or half spacings. If you accidentally mix resistivity and resistance values, set value_kind later when analyzing.","title":"Create Measurements"},{"location":"11_create_measurements/#create-measurements","text":"This tutorial covers how to create measurements for two real-world scenarios: a staged fault test and a soil resistivity survey.","title":"Create measurements"},{"location":"11_create_measurements/#physical-background","text":"Earthing impedance relates Earth Potential Rise to injected current. \\[ Z_E(f) = \\frac{V_{EPR}(f)}{I_E(f)} \\] Soil resistivity surveys estimate apparent resistivity. Wenner array formula: \\[ \\rho_a = 2 \\pi a R \\] Schlumberger array formula: \\[ \\rho_a = \\pi \\frac{AB^2 - MN^2}{4 MN} R \\]","title":"Physical background"},{"location":"11_create_measurements/#function-overview","text":"create_measurement creates a measurement record. create_item stores impedance, current, voltage, or soil resistivity items. read_items_by helps verify inserted items.","title":"Function overview"},{"location":"11_create_measurements/#inputs-and-outputs","text":"Function Input Output Description create_measurement measurement dict measurement id Create a measurement with optional location. create_item item dict, measurement_id item id Create an item linked to a measurement. read_items_by filters list of items Read items for verification.","title":"Inputs and outputs"},{"location":"11_create_measurements/#general-workflow","text":"","title":"General workflow"},{"location":"11_create_measurements/#scenario-a-staged-fault-test","text":"Create a measurement with method staged_fault_test and location metadata. Add earthing_impedance items for each distance. Add shield_current or earth_fault_current if available. Verify item count and distances.","title":"Scenario A: staged fault test"},{"location":"11_create_measurements/#scenario-b-soil-resistivity-survey","text":"Create a measurement with method wenner or schlumberger . Add soil_resistivity items at each spacing. Store spacing in measurement_distance_m . Store MN spacing in distance_to_current_injection_m for Schlumberger if needed.","title":"Scenario B: soil resistivity survey"},{"location":"11_create_measurements/#python-api-examples","text":"","title":"Python API examples"},{"location":"11_create_measurements/#scenario-a-staged-fault-test_1","text":"from groundmeas.db import connect_db , create_measurement , create_item , read_items_by connect_db ( \"groundmeas.db\" ) mid = create_measurement ({ \"method\" : \"staged_fault_test\" , \"asset_type\" : \"substation\" , \"voltage_level_kv\" : 20.0 , \"fault_resistance_ohm\" : 1.0 , \"description\" : \"Staged fault test\" , \"location\" : { \"name\" : \"Substation West\" }, }) for dist , value in [( 10 , 0.40 ), ( 30 , 0.36 ), ( 50 , 0.34 )]: create_item ({ \"measurement_type\" : \"earthing_impedance\" , \"frequency_hz\" : 50.0 , \"value\" : value , \"value_angle_deg\" : 0.0 , \"unit\" : \"ohm\" , \"measurement_distance_m\" : float ( dist ), \"distance_to_current_injection_m\" : 200.0 , }, measurement_id = mid ) create_item ({ \"measurement_type\" : \"shield_current\" , \"frequency_hz\" : 50.0 , \"value\" : 45.0 , \"value_angle_deg\" : - 10.0 , \"unit\" : \"A\" , }, measurement_id = mid ) items , _ = read_items_by ( measurement_id = mid ) print ( len ( items ))","title":"Scenario A: staged fault test"},{"location":"11_create_measurements/#scenario-b-soil-resistivity-survey_1","text":"from groundmeas.db import connect_db , create_measurement , create_item connect_db ( \"groundmeas.db\" ) soil_id = create_measurement ({ \"method\" : \"schlumberger\" , \"asset_type\" : \"substation\" , \"description\" : \"Schlumberger survey\" , \"location\" : { \"name\" : \"Substation West\" }, }) # Store AB/2 in measurement_distance_m, MN/2 in distance_to_current_injection_m for ab2 , mn2 , r in [( 1.0 , 0.5 , 12.0 ), ( 2.0 , 0.5 , 10.5 ), ( 4.0 , 0.5 , 9.0 )]: create_item ({ \"measurement_type\" : \"soil_resistivity\" , \"value\" : r , \"unit\" : \"ohm\" , \"measurement_distance_m\" : ab2 , \"distance_to_current_injection_m\" : mn2 , }, measurement_id = soil_id )","title":"Scenario B: soil resistivity survey"},{"location":"11_create_measurements/#cli-examples","text":"","title":"CLI examples"},{"location":"11_create_measurements/#scenario-a-staged-fault-test_2","text":"gm-cli add-measurement # Add impedance points for d in 10 30 50 ; do gm-cli add-item MEAS_ID # choose earthing_impedance, set frequency 50, value, and distance $d # set distance_to_current_injection_m to 200 done gm-cli add-item MEAS_ID # choose shield_current and enter value","title":"Scenario A: staged fault test"},{"location":"11_create_measurements/#scenario-b-soil-resistivity-survey_2","text":"gm-cli add-measurement # Add soil resistivity items for each spacing for a in 1 2 4 ; do gm-cli add-item SOIL_MEAS_ID # choose soil_resistivity, set value, and spacing $a done","title":"Scenario B: soil resistivity survey"},{"location":"11_create_measurements/#additional-notes","text":"Use consistent units (ohm, ohm-m) across a survey. For Schlumberger, confirm whether you store full or half spacings. If you accidentally mix resistivity and resistance values, set value_kind later when analyzing.","title":"Additional notes"},{"location":"12_read_measurements/","text":"Read measurements This tutorial shows how to inspect measurements, verify metadata, and validate soil survey inputs before running analytics. Physical background Not applicable for pure data inspection. This tutorial focuses on data integrity and validation. Function overview read_measurements_by loads measurements and nested items. read_items_by filters items by type, frequency, and distance. distance_profile_value provides a quick validation check for impedance data. soil_resistivity_curve exposes spacing and apparent resistivity points for surveys. Inputs and outputs Function Input Output Description read_measurements_by filters list of measurements Load measurements with items and location. read_items_by filters list of items Filter items by type or frequency. distance_profile_value measurement id, algorithm dict Quick impedance sanity check. soil_resistivity_curve measurement id, method list of points View spacing vs apparent resistivity. General workflow Scenario A: staged fault test QA List measurements and identify the staged fault test. Filter impedance items by frequency. Verify distances and units. Run a distance-profile reduction to check the curve. Scenario B: soil survey QA List soil survey measurements. Read soil resistivity items. Verify spacings and units. Build a spacing curve for review. Python API examples Scenario A: staged fault test QA from groundmeas.db import connect_db , read_measurements_by , read_items_by from groundmeas.analytics import distance_profile_value connect_db ( \"groundmeas.db\" ) meas , _ = read_measurements_by ( method = \"staged_fault_test\" ) mid = meas [ 0 ][ \"id\" ] items , _ = read_items_by ( measurement_id = mid , measurement_type = \"earthing_impedance\" , frequency_hz = 50.0 , ) print ([ it [ \"measurement_distance_m\" ] for it in items ]) check = distance_profile_value ( mid , algorithm = \"minimum_gradient\" ) print ( check [ \"result_value\" ], check [ \"result_distance_m\" ]) Scenario B: soil survey QA from groundmeas.db import connect_db , read_measurements_by from groundmeas.analytics import soil_resistivity_curve connect_db ( \"groundmeas.db\" ) meas , _ = read_measurements_by ( method = \"wenner\" ) soil_id = meas [ 0 ][ \"id\" ] curve = soil_resistivity_curve ( soil_id , method = \"wenner\" ) print ( curve ) CLI examples Scenario A: staged fault test QA gm-cli list-measurements gm-cli list-items MEAS_ID --type earthing_impedance gm-cli distance-profile MEAS_ID --type earthing_impedance --algorithm minimum_gradient Scenario B: soil survey QA gm-cli list-measurements gm-cli list-items SOIL_MEAS_ID --type soil_resistivity gm-cli soil-profile SOIL_MEAS_ID --method wenner Additional notes Missing measurement_distance_m causes distance-based analytics to skip items. If units are inconsistent, value_kind=\"auto\" can misclassify resistance vs resistivity. For Schlumberger, confirm whether spacing is AB or AB/2 before interpreting results. For QA, compare multiple reduction algorithms (maximum, 62_percent, minimum_gradient, minimum_stddev, inverse); see Distance profile reduction .","title":"Read Measurements"},{"location":"12_read_measurements/#read-measurements","text":"This tutorial shows how to inspect measurements, verify metadata, and validate soil survey inputs before running analytics.","title":"Read measurements"},{"location":"12_read_measurements/#physical-background","text":"Not applicable for pure data inspection. This tutorial focuses on data integrity and validation.","title":"Physical background"},{"location":"12_read_measurements/#function-overview","text":"read_measurements_by loads measurements and nested items. read_items_by filters items by type, frequency, and distance. distance_profile_value provides a quick validation check for impedance data. soil_resistivity_curve exposes spacing and apparent resistivity points for surveys.","title":"Function overview"},{"location":"12_read_measurements/#inputs-and-outputs","text":"Function Input Output Description read_measurements_by filters list of measurements Load measurements with items and location. read_items_by filters list of items Filter items by type or frequency. distance_profile_value measurement id, algorithm dict Quick impedance sanity check. soil_resistivity_curve measurement id, method list of points View spacing vs apparent resistivity.","title":"Inputs and outputs"},{"location":"12_read_measurements/#general-workflow","text":"","title":"General workflow"},{"location":"12_read_measurements/#scenario-a-staged-fault-test-qa","text":"List measurements and identify the staged fault test. Filter impedance items by frequency. Verify distances and units. Run a distance-profile reduction to check the curve.","title":"Scenario A: staged fault test QA"},{"location":"12_read_measurements/#scenario-b-soil-survey-qa","text":"List soil survey measurements. Read soil resistivity items. Verify spacings and units. Build a spacing curve for review.","title":"Scenario B: soil survey QA"},{"location":"12_read_measurements/#python-api-examples","text":"","title":"Python API examples"},{"location":"12_read_measurements/#scenario-a-staged-fault-test-qa_1","text":"from groundmeas.db import connect_db , read_measurements_by , read_items_by from groundmeas.analytics import distance_profile_value connect_db ( \"groundmeas.db\" ) meas , _ = read_measurements_by ( method = \"staged_fault_test\" ) mid = meas [ 0 ][ \"id\" ] items , _ = read_items_by ( measurement_id = mid , measurement_type = \"earthing_impedance\" , frequency_hz = 50.0 , ) print ([ it [ \"measurement_distance_m\" ] for it in items ]) check = distance_profile_value ( mid , algorithm = \"minimum_gradient\" ) print ( check [ \"result_value\" ], check [ \"result_distance_m\" ])","title":"Scenario A: staged fault test QA"},{"location":"12_read_measurements/#scenario-b-soil-survey-qa_1","text":"from groundmeas.db import connect_db , read_measurements_by from groundmeas.analytics import soil_resistivity_curve connect_db ( \"groundmeas.db\" ) meas , _ = read_measurements_by ( method = \"wenner\" ) soil_id = meas [ 0 ][ \"id\" ] curve = soil_resistivity_curve ( soil_id , method = \"wenner\" ) print ( curve )","title":"Scenario B: soil survey QA"},{"location":"12_read_measurements/#cli-examples","text":"","title":"CLI examples"},{"location":"12_read_measurements/#scenario-a-staged-fault-test-qa_2","text":"gm-cli list-measurements gm-cli list-items MEAS_ID --type earthing_impedance gm-cli distance-profile MEAS_ID --type earthing_impedance --algorithm minimum_gradient","title":"Scenario A: staged fault test QA"},{"location":"12_read_measurements/#scenario-b-soil-survey-qa_2","text":"gm-cli list-measurements gm-cli list-items SOIL_MEAS_ID --type soil_resistivity gm-cli soil-profile SOIL_MEAS_ID --method wenner","title":"Scenario B: soil survey QA"},{"location":"12_read_measurements/#additional-notes","text":"Missing measurement_distance_m causes distance-based analytics to skip items. If units are inconsistent, value_kind=\"auto\" can misclassify resistance vs resistivity. For Schlumberger, confirm whether spacing is AB or AB/2 before interpreting results. For QA, compare multiple reduction algorithms (maximum, 62_percent, minimum_gradient, minimum_stddev, inverse); see Distance profile reduction .","title":"Additional notes"},{"location":"13_change_measurements/","text":"Change measurements This tutorial shows how to update metadata, fix item values, and remove erroneous points. Physical background Not applicable. This tutorial focuses on editing stored data. Function overview update_measurement edits measurement metadata and location. update_item edits a measurement item and its value representation. delete_item removes a single item. delete_measurement removes a measurement and its items. Inputs and outputs Function Input Output Description update_measurement measurement id, updates bool Update measurement fields. update_item item id, updates bool Update item fields or representation. delete_item item id bool Delete one item. delete_measurement measurement id bool Delete measurement and items. General workflow Scenario A: staged fault test correction Export a JSON snapshot as a backup. Update the measurement description and operator. Correct the impedance value at the wrong distance. Re-run distance-profile analytics. Scenario B: soil survey correction Export a JSON snapshot. Fix an incorrect spacing or unit. Remove an outlier point. Rebuild the soil profile and check the curve. Python API examples Scenario A: staged fault test correction from groundmeas.db import connect_db , update_measurement , update_item from groundmeas.analytics import distance_profile_value connect_db ( \"groundmeas.db\" ) update_measurement ( 1 , { \"description\" : \"Retested after maintenance\" , \"operator\" : \"Ops Team\" , }) update_item ( 10 , { \"measurement_type\" : \"earthing_impedance\" , \"frequency_hz\" : 50.0 , \"value\" : 0.34 , \"value_angle_deg\" : 0.0 , \"unit\" : \"ohm\" , \"measurement_distance_m\" : 50.0 , }) check = distance_profile_value ( 1 , algorithm = \"minimum_gradient\" ) print ( check [ \"result_value\" ]) Scenario B: soil survey correction from groundmeas.db import connect_db , update_item , delete_item from groundmeas.analytics import soil_resistivity_profile connect_db ( \"groundmeas.db\" ) # Fix spacing and unit for item 21 update_item ( 21 , { \"measurement_type\" : \"soil_resistivity\" , \"measurement_distance_m\" : 4.0 , \"value\" : 60.0 , \"unit\" : \"ohm-m\" , }) # Remove an outlier ok = delete_item ( 22 ) print ( ok ) profile = soil_resistivity_profile ( 2 , method = \"wenner\" ) print ( profile ) CLI examples Scenario A: staged fault test correction gm-cli export-json backup.json --measurement-id 1 gm-cli edit-measurement 1 gm-cli edit-item 10 gm-cli distance-profile 1 --type earthing_impedance --algorithm minimum_gradient Scenario B: soil survey correction gm-cli export-json backup.json --measurement-id 2 gm-cli edit-item 21 gm-cli delete-item 22 --yes gm-cli soil-profile 2 --method wenner Additional notes When changing value representation, clear unused fields to avoid stale values. Always export a backup before deleting items. If you adjust spacing, re-check the profile and inversion results.","title":"Change Measurements"},{"location":"13_change_measurements/#change-measurements","text":"This tutorial shows how to update metadata, fix item values, and remove erroneous points.","title":"Change measurements"},{"location":"13_change_measurements/#physical-background","text":"Not applicable. This tutorial focuses on editing stored data.","title":"Physical background"},{"location":"13_change_measurements/#function-overview","text":"update_measurement edits measurement metadata and location. update_item edits a measurement item and its value representation. delete_item removes a single item. delete_measurement removes a measurement and its items.","title":"Function overview"},{"location":"13_change_measurements/#inputs-and-outputs","text":"Function Input Output Description update_measurement measurement id, updates bool Update measurement fields. update_item item id, updates bool Update item fields or representation. delete_item item id bool Delete one item. delete_measurement measurement id bool Delete measurement and items.","title":"Inputs and outputs"},{"location":"13_change_measurements/#general-workflow","text":"","title":"General workflow"},{"location":"13_change_measurements/#scenario-a-staged-fault-test-correction","text":"Export a JSON snapshot as a backup. Update the measurement description and operator. Correct the impedance value at the wrong distance. Re-run distance-profile analytics.","title":"Scenario A: staged fault test correction"},{"location":"13_change_measurements/#scenario-b-soil-survey-correction","text":"Export a JSON snapshot. Fix an incorrect spacing or unit. Remove an outlier point. Rebuild the soil profile and check the curve.","title":"Scenario B: soil survey correction"},{"location":"13_change_measurements/#python-api-examples","text":"","title":"Python API examples"},{"location":"13_change_measurements/#scenario-a-staged-fault-test-correction_1","text":"from groundmeas.db import connect_db , update_measurement , update_item from groundmeas.analytics import distance_profile_value connect_db ( \"groundmeas.db\" ) update_measurement ( 1 , { \"description\" : \"Retested after maintenance\" , \"operator\" : \"Ops Team\" , }) update_item ( 10 , { \"measurement_type\" : \"earthing_impedance\" , \"frequency_hz\" : 50.0 , \"value\" : 0.34 , \"value_angle_deg\" : 0.0 , \"unit\" : \"ohm\" , \"measurement_distance_m\" : 50.0 , }) check = distance_profile_value ( 1 , algorithm = \"minimum_gradient\" ) print ( check [ \"result_value\" ])","title":"Scenario A: staged fault test correction"},{"location":"13_change_measurements/#scenario-b-soil-survey-correction_1","text":"from groundmeas.db import connect_db , update_item , delete_item from groundmeas.analytics import soil_resistivity_profile connect_db ( \"groundmeas.db\" ) # Fix spacing and unit for item 21 update_item ( 21 , { \"measurement_type\" : \"soil_resistivity\" , \"measurement_distance_m\" : 4.0 , \"value\" : 60.0 , \"unit\" : \"ohm-m\" , }) # Remove an outlier ok = delete_item ( 22 ) print ( ok ) profile = soil_resistivity_profile ( 2 , method = \"wenner\" ) print ( profile )","title":"Scenario B: soil survey correction"},{"location":"13_change_measurements/#cli-examples","text":"","title":"CLI examples"},{"location":"13_change_measurements/#scenario-a-staged-fault-test-correction_2","text":"gm-cli export-json backup.json --measurement-id 1 gm-cli edit-measurement 1 gm-cli edit-item 10 gm-cli distance-profile 1 --type earthing_impedance --algorithm minimum_gradient","title":"Scenario A: staged fault test correction"},{"location":"13_change_measurements/#scenario-b-soil-survey-correction_2","text":"gm-cli export-json backup.json --measurement-id 2 gm-cli edit-item 21 gm-cli delete-item 22 --yes gm-cli soil-profile 2 --method wenner","title":"Scenario B: soil survey correction"},{"location":"13_change_measurements/#additional-notes","text":"When changing value representation, clear unused fields to avoid stale values. Always export a backup before deleting items. If you adjust spacing, re-check the profile and inversion results.","title":"Additional notes"},{"location":"14_import_export/","text":"Import and export This tutorial covers JSON, CSV, and XML export, JSON import, and OCR-based import from measurement images. Physical background Not applicable. This tutorial focuses on data transfer and ingestion. Function overview export_measurements_to_json , export_measurements_to_csv , export_measurements_to_xml export measurement data. import_items_from_images runs OCR and creates items from images. CLI commands import-json , export-json , and import-from-images provide the same capabilities. Inputs and outputs Function Input Output Description export_measurements_to_json path , filters none Write measurements to JSON. export_measurements_to_csv path , filters none Write measurements to CSV. export_measurements_to_xml path , filters none Write measurements to XML. import_items_from_images images dir, measurement id summary dict OCR import of items from images. General workflow Scenario A: share measurements Export measurements to JSON or CSV. Send the file to collaborators. Import the JSON into another database. Scenario B: OCR import Collect images of measurement tables. Run OCR import for a target measurement. Validate the imported items. Python API examples Scenario A: export and share from groundmeas.db import connect_db from groundmeas.export import export_measurements_to_json , export_measurements_to_csv connect_db ( \"groundmeas.db\" ) export_measurements_to_json ( \"export/site_a.json\" , id__in = [ 1 ]) export_measurements_to_csv ( \"export/site_a.csv\" , id__in = [ 1 ]) Scenario B: OCR import from groundmeas.db import connect_db from groundmeas.vision_import import import_items_from_images connect_db ( \"groundmeas.db\" ) summary = import_items_from_images ( images_dir = \"images/site_a\" , measurement_id = 1 , measurement_type = \"earthing_impedance\" , frequency_hz = \"dir\" , distance_to_current_injection_m = 200.0 , ocr_provider = \"tesseract\" , ) print ( summary ) CLI examples Scenario A: export and import gm-cli export-json export/site_a.json --measurement-id 1 gm-cli import-json export/site_a.json Scenario B: OCR import gm-cli import-from-images 1 images/site_a \\ --type earthing_impedance \\ --frequency dir \\ --ocr tesseract \\ --injection-distance 200 Additional notes CSV export stores items as a JSON string and is not round-trip safe. OCR can misread decimal separators; validate imports before analysis. Use --json-out in CLI commands to capture structured output for automation.","title":"Import & Export"},{"location":"14_import_export/#import-and-export","text":"This tutorial covers JSON, CSV, and XML export, JSON import, and OCR-based import from measurement images.","title":"Import and export"},{"location":"14_import_export/#physical-background","text":"Not applicable. This tutorial focuses on data transfer and ingestion.","title":"Physical background"},{"location":"14_import_export/#function-overview","text":"export_measurements_to_json , export_measurements_to_csv , export_measurements_to_xml export measurement data. import_items_from_images runs OCR and creates items from images. CLI commands import-json , export-json , and import-from-images provide the same capabilities.","title":"Function overview"},{"location":"14_import_export/#inputs-and-outputs","text":"Function Input Output Description export_measurements_to_json path , filters none Write measurements to JSON. export_measurements_to_csv path , filters none Write measurements to CSV. export_measurements_to_xml path , filters none Write measurements to XML. import_items_from_images images dir, measurement id summary dict OCR import of items from images.","title":"Inputs and outputs"},{"location":"14_import_export/#general-workflow","text":"","title":"General workflow"},{"location":"14_import_export/#scenario-a-share-measurements","text":"Export measurements to JSON or CSV. Send the file to collaborators. Import the JSON into another database.","title":"Scenario A: share measurements"},{"location":"14_import_export/#scenario-b-ocr-import","text":"Collect images of measurement tables. Run OCR import for a target measurement. Validate the imported items.","title":"Scenario B: OCR import"},{"location":"14_import_export/#python-api-examples","text":"","title":"Python API examples"},{"location":"14_import_export/#scenario-a-export-and-share","text":"from groundmeas.db import connect_db from groundmeas.export import export_measurements_to_json , export_measurements_to_csv connect_db ( \"groundmeas.db\" ) export_measurements_to_json ( \"export/site_a.json\" , id__in = [ 1 ]) export_measurements_to_csv ( \"export/site_a.csv\" , id__in = [ 1 ])","title":"Scenario A: export and share"},{"location":"14_import_export/#scenario-b-ocr-import_1","text":"from groundmeas.db import connect_db from groundmeas.vision_import import import_items_from_images connect_db ( \"groundmeas.db\" ) summary = import_items_from_images ( images_dir = \"images/site_a\" , measurement_id = 1 , measurement_type = \"earthing_impedance\" , frequency_hz = \"dir\" , distance_to_current_injection_m = 200.0 , ocr_provider = \"tesseract\" , ) print ( summary )","title":"Scenario B: OCR import"},{"location":"14_import_export/#cli-examples","text":"","title":"CLI examples"},{"location":"14_import_export/#scenario-a-export-and-import","text":"gm-cli export-json export/site_a.json --measurement-id 1 gm-cli import-json export/site_a.json","title":"Scenario A: export and import"},{"location":"14_import_export/#scenario-b-ocr-import_2","text":"gm-cli import-from-images 1 images/site_a \\ --type earthing_impedance \\ --frequency dir \\ --ocr tesseract \\ --injection-distance 200","title":"Scenario B: OCR import"},{"location":"14_import_export/#additional-notes","text":"CSV export stores items as a JSON string and is not round-trip safe. OCR can misread decimal separators; validate imports before analysis. Use --json-out in CLI commands to capture structured output for automation.","title":"Additional notes"},{"location":"15_analytics/","text":"Analytics This tutorial provides detailed, function-by-function guidance for the analytics module. Each section includes background, inputs and outputs, workflows, Python API examples, CLI examples, and practical notes. Impedance over frequency Physical background Impedance varies with frequency due to inductive and capacitive effects. Frequency curves are used for comparing measurements and fitting the rho-f model. Function overview impedance_over_frequency maps frequency to impedance magnitude. real_imag_over_frequency maps frequency to real and imaginary components. Inputs and outputs Function Input Output Description impedance_over_frequency measurement id or list dict Map frequency to impedance magnitude. real_imag_over_frequency measurement id or list dict Map frequency to real and imaginary values. General workflow Ensure impedance items have frequency_hz populated. Query impedance or real/imag maps. Compare curves across measurements. Use the result for plotting or further modeling. Python API examples Scenario A: single measurement from groundmeas.db import connect_db from groundmeas.analytics import impedance_over_frequency connect_db ( \"groundmeas.db\" ) imp_map = impedance_over_frequency ( 1 ) print ( imp_map ) Scenario B: multiple measurements and real/imag from groundmeas.db import connect_db from groundmeas.analytics import real_imag_over_frequency connect_db ( \"groundmeas.db\" ) ri_map = real_imag_over_frequency ([ 1 , 2 , 3 ]) print ( ri_map [ 1 ]) CLI examples Scenario A: single measurement gm-cli impedance-over-frequency 1 Scenario B: multiple measurements gm-cli real-imag-over-frequency 1 2 3 --json-out out.json Additional notes Missing frequency_hz values are skipped. If impedance values are stored as real and imag, ensure the value field is populated or use the real/imag function. Use the Plotly dashboard for quick visual comparison. Distance profile reduction Physical background Fall-of-Potential tests measure impedance versus distance between the voltage probe and the earthing system. As the probe moves away, the measured impedance approaches the \"remote earth\" value. In practice the curve can flatten slowly, show a shallow maximum, or contain noise from soil inhomogeneity, coupling, and probe placement. Reduction algorithms estimate one characteristic impedance from the distance series. Inverse extrapolation formula (1/Z method): \\[ \\frac{1}{Z} = a \\cdot \\frac{1}{d} + b \\] At infinite distance (1/d -> 0), 1/Z approaches the intercept b, so the extrapolated impedance is Z_infinity = 1/b. Function overview distance_profile_value reduces a distance profile to one value using several algorithms. Inputs and outputs Function Input Output Description distance_profile_value measurement id, algorithm, window dict Return characteristic value and metadata. General workflow Verify impedance items have measurement_distance_m and value . If multiple frequencies exist, filter to a single frequency first. Choose a reduction algorithm that matches the test geometry and data quality. Run the reduction and inspect result_distance_m and details . Compare with other algorithms if needed. Algorithm behavior in groundmeas Maximum The maximum method returns the measured point with the highest impedance value. It assumes the survey captured the true maximum of the distance curve. If the maximum was missed, the result will be too low. This can be a conservative choice when the maximum is clearly identified. Implementation details: - Uses the single point with max(value) . - details.point includes the chosen point. 62 percent (IEEE 80) IEEE Std 80 describes a colinear arrangement of electrode, current probe, and potential probe in homogeneous soil. Under those assumptions, the potential contributions cancel at 62% of the current-probe distance, so Z at 0.62 * D is the earthing impedance. Implementation details: - Requires distance_to_current_injection_m on the items. - Target distance = 0.62 * distance_to_current_injection_m. - Uses linear interpolation of the nearest distances (up to 3 points). - result_distance_m equals the target distance; details.used_points lists the interpolation points. Minimum gradient The minimum-gradient method finds the location where the slope dZ/dd is closest to zero. The idea is that a flat section of the curve indicates the remote-earth region, so the impedance at that distance is the characteristic value. Implementation details: - Computes numerical gradients from the sorted distance series. - Picks the point with the smallest absolute gradient. - details.gradient records the gradient value at that point. Minimum standard deviation This method scans the curve with a fixed-size window and finds the segment with the smallest standard deviation. A stable segment indicates a flat, remote-earth region. The algorithm returns the maximum value within the best window to remain conservative while reducing sensitivity to single outliers. Implementation details: - Uses window points per segment. - Picks the window with the lowest stddev(values) . - Returns the maximum value inside that window. - details.window_points and details.stddev explain the chosen segment. Inverse extrapolation (1/Z) The inverse method fits a straight line to 1/Z versus 1/d and extrapolates to infinite distance. This is useful when the curve is still rising and remote earth is not clearly reached, but it can overestimate if the data range is short or noisy. Implementation details: - Fits a line to x = 1/d and y = 1/Z. - Extrapolates to x = 0 to get y = b, then Z_infinity = 1/b. - Returns result_distance_m = inf to indicate extrapolation. - Requires non-zero distances and values. Example curve (minimum standard deviation) This plot shows the minimum standard deviation window used to select a stable region of the distance curve. Choosing an algorithm Use 62% when the geometry matches IEEE 80 assumptions (colinear probes, homogeneous soil) and you have a reliable injection distance. Use minimum gradient when the curve flattens clearly and noise is low. Use minimum standard deviation when the curve is noisy but you expect a stable plateau; increase window to smooth more. Use maximum when you intentionally search for and confirm the peak in the curve. Use inverse when remote earth is not fully reached; treat it as an extrapolation that can be conservative. Python API examples Scenario A: maximum method from groundmeas.db import connect_db from groundmeas.analytics import distance_profile_value connect_db ( \"groundmeas.db\" ) result = distance_profile_value ( 1 , algorithm = \"maximum\" ) print ( result [ \"result_value\" ], result [ \"result_distance_m\" ]) Scenario B: 62 percent method from groundmeas.db import connect_db from groundmeas.analytics import distance_profile_value connect_db ( \"groundmeas.db\" ) result = distance_profile_value ( 1 , algorithm = \"62_percent\" ) print ( result ) Scenario C: minimum standard deviation with a larger window from groundmeas.db import connect_db from groundmeas.analytics import distance_profile_value connect_db ( \"groundmeas.db\" ) result = distance_profile_value ( 1 , algorithm = \"minimum_stddev\" , window = 5 ) print ( result [ \"result_value\" ], result [ \"details\" ][ \"stddev\" ]) CLI examples Scenario A: minimum gradient gm-cli distance-profile 1 --type earthing_impedance --algorithm minimum_gradient Scenario B: inverse extrapolation gm-cli distance-profile 1 --type earthing_impedance --algorithm inverse Additional notes The 62 percent method requires consistent distance_to_current_injection_m values; mixed values trigger a warning and the first value is used. Duplicate distances are deduplicated by choosing the point closest to linear interpolation between neighbors. For inverse, distances and values must be non-zero. Results depend on distance coverage; short or sparse curves can bias any reduction. Rho-f model fitting Physical background The rho-f model links impedance to soil resistivity and frequency. It uses complex coefficients fitted from data. \\[ Z(\\rho, f) = k_1 \\cdot \\rho + (k_2 + j k_3) \\cdot f + (k_4 + j k_5) \\cdot \\rho \\cdot f \\] Function overview rho_f_model fits k1 to k5 from impedance and soil resistivity data. Inputs and outputs Function Input Output Description rho_f_model measurement ids tuple Fit coefficients k1 to k5. General workflow Ensure impedance data and soil resistivity data overlap in frequency. Call the fit function with one or more measurements. Validate coefficients by plotting model curves. Python API examples Scenario A: single measurement from groundmeas.db import connect_db from groundmeas.analytics import rho_f_model connect_db ( \"groundmeas.db\" ) k1 , k2 , k3 , k4 , k5 = rho_f_model ([ 1 ]) print ( k1 , k2 , k3 , k4 , k5 ) Scenario B: combined fit from groundmeas.db import connect_db from groundmeas.analytics import rho_f_model connect_db ( \"groundmeas.db\" ) coeffs = rho_f_model ([ 1 , 2 , 3 ]) print ( coeffs ) CLI examples Scenario A: one measurement gm-cli rho-f-model 1 Scenario B: multiple measurements gm-cli rho-f-model 1 2 3 --json-out rho_f.json Additional notes The fit requires real and imag impedance values plus soil resistivity values. If frequencies do not overlap, the fit may fail or return poor coefficients. Use plot-rho-f-model to inspect the fit visually. Voltage, touch voltage, and EPR Physical background Earth Potential Rise follows impedance and current. \\[ EPR = Z_E \\cdot I_E \\] Function overview voltage_vt_epr computes EPR and touch voltage summaries per measurement. Inputs and outputs Function Input Output Description voltage_vt_epr measurement id or list, frequency dict EPR and touch voltage summary. General workflow Ensure impedance and current items share the same frequency. Call the function with one or more measurements. Inspect EPR and voltage ranges. Python API examples Scenario A: single measurement from groundmeas.db import connect_db from groundmeas.analytics import voltage_vt_epr connect_db ( \"groundmeas.db\" ) summary = voltage_vt_epr ( 1 , frequency = 50.0 ) print ( summary ) Scenario B: multiple measurements from groundmeas.db import connect_db from groundmeas.analytics import voltage_vt_epr connect_db ( \"groundmeas.db\" ) summary = voltage_vt_epr ([ 1 , 2 ], frequency = 50.0 ) print ( summary ) CLI examples Scenario A: one measurement gm-cli voltage-vt-epr 1 --frequency 50 Scenario B: multiple measurements gm-cli voltage-vt-epr 1 2 --frequency 50 --json-out vt.json Additional notes If current or impedance data is missing, outputs will be incomplete. Use consistent units for current and impedance values. Shield currents and split factor Physical background Earth fault current can split between cable shields and the local earthing system. The split factor quantifies that ratio. Function overview shield_currents_for_location lists shield current items for a location. calculate_split_factor computes the split factor and derived currents. Inputs and outputs Function Input Output Description shield_currents_for_location location id, frequency list Shield current items. calculate_split_factor earth fault item id, shield item ids dict Split factor and current components. General workflow Identify a location and available shield current items. Select the earth fault current item. Compute the split factor using selected shield currents. Python API examples Scenario A: list shield currents from groundmeas.db import connect_db from groundmeas.analytics import shield_currents_for_location connect_db ( \"groundmeas.db\" ) shield_items = shield_currents_for_location ( location_id = 1 , frequency_hz = 50.0 ) print ( shield_items ) Scenario B: compute split factor from groundmeas.db import connect_db from groundmeas.analytics import calculate_split_factor connect_db ( \"groundmeas.db\" ) result = calculate_split_factor ( earth_fault_current_id = 100 , shield_current_ids = [ 201 , 202 ], ) print ( result ) CLI examples Scenario A: list shield currents gm-cli shield-currents 1 --frequency 50 Scenario B: split factor gm-cli calculate-split-factor --earth-fault-id 100 --shield-id 201 --shield-id 202 Additional notes Use consistent reference direction and frequency across shield current items. Mixed polar and rectangular values are supported, but avoid mixing units. Value over distance mappings Physical background Not applicable. These functions provide distance-based mappings for plotting and QA. Function overview value_over_distance returns a simple distance to value map. value_over_distance_detailed returns distance, value, and frequency points. Inputs and outputs Function Input Output Description value_over_distance measurement id or list, type dict Distance to value map. value_over_distance_detailed measurement id or list, type list or dict Detailed points with frequency. General workflow Filter by measurement type (impedance, resistance, soil resistivity). Use the simple map for quick plots or checks. Use the detailed map when frequency separation matters. Python API examples Scenario A: simple map from groundmeas.db import connect_db from groundmeas.analytics import value_over_distance connect_db ( \"groundmeas.db\" ) dist_map = value_over_distance ( 1 , measurement_type = \"earthing_impedance\" ) print ( dist_map ) Scenario B: detailed map from groundmeas.db import connect_db from groundmeas.analytics import value_over_distance_detailed connect_db ( \"groundmeas.db\" ) points = value_over_distance_detailed ([ 1 , 2 ], measurement_type = \"earthing_impedance\" ) print ( points [ 1 ][: 3 ]) CLI examples Scenario A: export and inspect gm-cli export-json out.json --measurement-id 1 Scenario B: list items for a specific type gm-cli list-items 1 --type earthing_impedance Additional notes There is no direct CLI command for these functions; use export or list-items for equivalent data. Missing measurement_distance_m values are ignored. Soil resistivity profiles Physical background Wenner and Schlumberger arrays estimate apparent resistivity from field measurements. Wenner: \\[ \\rho_a = 2 \\pi a R \\] Schlumberger: \\[ \\rho_a = \\pi \\frac{AB^2 - MN^2}{4 MN} R \\] Function overview soil_resistivity_profile_detailed returns depth and spacing detail. soil_resistivity_profile returns depth to resistivity map. soil_resistivity_curve returns spacing to resistivity points. Inputs and outputs Function Input Output Description soil_resistivity_profile_detailed measurement id, method, options list Detailed depth and spacing points. soil_resistivity_profile measurement id, method, options dict Depth to resistivity map. soil_resistivity_curve measurement id, method, options list Spacing to resistivity points. General workflow Store soil resistivity or resistance values with spacing. Choose Wenner or Schlumberger method. Build a depth profile for QA. Use the spacing curve for inversion. Python API examples Scenario A: Wenner resistivity values from groundmeas.db import connect_db from groundmeas.analytics import soil_resistivity_profile connect_db ( \"groundmeas.db\" ) profile = soil_resistivity_profile ( 2 , method = \"wenner\" ) print ( profile ) Scenario B: Schlumberger resistance values from groundmeas.db import connect_db from groundmeas.analytics import soil_resistivity_profile_detailed connect_db ( \"groundmeas.db\" ) profile = soil_resistivity_profile_detailed ( measurement_id = 3 , method = \"schlumberger\" , value_kind = \"resistance\" , ab_is_full = False , mn_is_full = False , ) print ( profile [: 3 ]) CLI examples Scenario A: Wenner profile gm-cli soil-profile 2 --method wenner Scenario B: Schlumberger profile with resistance values gm-cli soil-profile 3 --method schlumberger --value-kind resistance Additional notes By default, Schlumberger spacing uses AB/2 and MN/2. Set ab_is_full or mn_is_full if you store full spacings. If units are missing, value_kind=auto assumes resistance. Layered earth model and inversion Physical background Layered earth models approximate soil resistivity changes with depth. Apparent resistivity curves are simulated with digital filters or an integral engine. Function overview LayeredEarthModel validates layer resistivities and thicknesses. multilayer_soil_model builds a layer table for reporting. layered_earth_forward simulates apparent resistivity for Wenner or Schlumberger. invert_layered_earth inverts spacing and apparent resistivity arrays. invert_soil_resistivity_layers inverts directly from stored soil items. Inputs and outputs Function Input Output Description LayeredEarthModel rho_layers , thicknesses_m object Validated layered earth model. multilayer_soil_model rho_layers , thicknesses_m dict Layer table and parameters. layered_earth_forward spacings, model params list Simulated apparent resistivity curve. invert_layered_earth spacings, observed rho, params dict Fitted layers and misfit stats. invert_soil_resistivity_layers measurement id, params dict Invert from stored soil survey. General workflow Choose 1 to 3 layers based on curve complexity. Set initial resistivities and thicknesses. Simulate the curve to sanity check the model. Run inversion and inspect misfit. Increase layer count only if needed. Python API examples Scenario A: forward simulation from groundmeas.analytics import layered_earth_forward spacings = [ 1.0 , 2.0 , 4.0 , 8.0 ] resistivities = [ 100.0 , 30.0 ] thicknesses = [ 2.0 ] pred = layered_earth_forward ( spacings_m = spacings , rho_layers = resistivities , thicknesses_m = thicknesses , method = \"wenner\" , ) print ( pred ) Scenario B: inversion from stored survey from groundmeas.db import connect_db from groundmeas.analytics import invert_soil_resistivity_layers connect_db ( \"groundmeas.db\" ) inv = invert_soil_resistivity_layers ( measurement_id = 2 , method = \"wenner\" , layers = 2 , initial_rho = [ 120.0 , 35.0 ], initial_thicknesses = [ 2.5 ], max_iter = 40 , damping = 0.1 , ) print ( inv [ \"rho_layers\" ], inv [ \"thicknesses_m\" ], inv [ \"misfit\" ]) CLI examples Scenario A: simulate a model gm-cli soil-model --rho 100 --rho 30 --thickness 2 \\ --method wenner --spacing 1 --spacing 2 --spacing 4 Scenario B: invert a model gm-cli soil-inversion 2 --layers 2 --method wenner \\ --initial-rho 120 --initial-rho 35 \\ --initial-thickness 2 .5 Additional notes The filter forward engine assumes MN is small compared to AB for Schlumberger. Use forward=integral when MN is not negligible (requires SciPy). Inversion can be sensitive to initial guesses; start with 1 layer and add complexity gradually. Use backend=\"mlx\" on Apple hardware if MLX is installed for speed.","title":"Analytics"},{"location":"15_analytics/#analytics","text":"This tutorial provides detailed, function-by-function guidance for the analytics module. Each section includes background, inputs and outputs, workflows, Python API examples, CLI examples, and practical notes.","title":"Analytics"},{"location":"15_analytics/#impedance-over-frequency","text":"","title":"Impedance over frequency"},{"location":"15_analytics/#physical-background","text":"Impedance varies with frequency due to inductive and capacitive effects. Frequency curves are used for comparing measurements and fitting the rho-f model.","title":"Physical background"},{"location":"15_analytics/#function-overview","text":"impedance_over_frequency maps frequency to impedance magnitude. real_imag_over_frequency maps frequency to real and imaginary components.","title":"Function overview"},{"location":"15_analytics/#inputs-and-outputs","text":"Function Input Output Description impedance_over_frequency measurement id or list dict Map frequency to impedance magnitude. real_imag_over_frequency measurement id or list dict Map frequency to real and imaginary values.","title":"Inputs and outputs"},{"location":"15_analytics/#general-workflow","text":"Ensure impedance items have frequency_hz populated. Query impedance or real/imag maps. Compare curves across measurements. Use the result for plotting or further modeling.","title":"General workflow"},{"location":"15_analytics/#python-api-examples","text":"Scenario A: single measurement from groundmeas.db import connect_db from groundmeas.analytics import impedance_over_frequency connect_db ( \"groundmeas.db\" ) imp_map = impedance_over_frequency ( 1 ) print ( imp_map ) Scenario B: multiple measurements and real/imag from groundmeas.db import connect_db from groundmeas.analytics import real_imag_over_frequency connect_db ( \"groundmeas.db\" ) ri_map = real_imag_over_frequency ([ 1 , 2 , 3 ]) print ( ri_map [ 1 ])","title":"Python API examples"},{"location":"15_analytics/#cli-examples","text":"Scenario A: single measurement gm-cli impedance-over-frequency 1 Scenario B: multiple measurements gm-cli real-imag-over-frequency 1 2 3 --json-out out.json","title":"CLI examples"},{"location":"15_analytics/#additional-notes","text":"Missing frequency_hz values are skipped. If impedance values are stored as real and imag, ensure the value field is populated or use the real/imag function. Use the Plotly dashboard for quick visual comparison.","title":"Additional notes"},{"location":"15_analytics/#distance-profile-reduction","text":"","title":"Distance profile reduction"},{"location":"15_analytics/#physical-background_1","text":"Fall-of-Potential tests measure impedance versus distance between the voltage probe and the earthing system. As the probe moves away, the measured impedance approaches the \"remote earth\" value. In practice the curve can flatten slowly, show a shallow maximum, or contain noise from soil inhomogeneity, coupling, and probe placement. Reduction algorithms estimate one characteristic impedance from the distance series. Inverse extrapolation formula (1/Z method): \\[ \\frac{1}{Z} = a \\cdot \\frac{1}{d} + b \\] At infinite distance (1/d -> 0), 1/Z approaches the intercept b, so the extrapolated impedance is Z_infinity = 1/b.","title":"Physical background"},{"location":"15_analytics/#function-overview_1","text":"distance_profile_value reduces a distance profile to one value using several algorithms.","title":"Function overview"},{"location":"15_analytics/#inputs-and-outputs_1","text":"Function Input Output Description distance_profile_value measurement id, algorithm, window dict Return characteristic value and metadata.","title":"Inputs and outputs"},{"location":"15_analytics/#general-workflow_1","text":"Verify impedance items have measurement_distance_m and value . If multiple frequencies exist, filter to a single frequency first. Choose a reduction algorithm that matches the test geometry and data quality. Run the reduction and inspect result_distance_m and details . Compare with other algorithms if needed.","title":"General workflow"},{"location":"15_analytics/#algorithm-behavior-in-groundmeas","text":"","title":"Algorithm behavior in groundmeas"},{"location":"15_analytics/#maximum","text":"The maximum method returns the measured point with the highest impedance value. It assumes the survey captured the true maximum of the distance curve. If the maximum was missed, the result will be too low. This can be a conservative choice when the maximum is clearly identified. Implementation details: - Uses the single point with max(value) . - details.point includes the chosen point.","title":"Maximum"},{"location":"15_analytics/#62-percent-ieee-80","text":"IEEE Std 80 describes a colinear arrangement of electrode, current probe, and potential probe in homogeneous soil. Under those assumptions, the potential contributions cancel at 62% of the current-probe distance, so Z at 0.62 * D is the earthing impedance. Implementation details: - Requires distance_to_current_injection_m on the items. - Target distance = 0.62 * distance_to_current_injection_m. - Uses linear interpolation of the nearest distances (up to 3 points). - result_distance_m equals the target distance; details.used_points lists the interpolation points.","title":"62 percent (IEEE 80)"},{"location":"15_analytics/#minimum-gradient","text":"The minimum-gradient method finds the location where the slope dZ/dd is closest to zero. The idea is that a flat section of the curve indicates the remote-earth region, so the impedance at that distance is the characteristic value. Implementation details: - Computes numerical gradients from the sorted distance series. - Picks the point with the smallest absolute gradient. - details.gradient records the gradient value at that point.","title":"Minimum gradient"},{"location":"15_analytics/#minimum-standard-deviation","text":"This method scans the curve with a fixed-size window and finds the segment with the smallest standard deviation. A stable segment indicates a flat, remote-earth region. The algorithm returns the maximum value within the best window to remain conservative while reducing sensitivity to single outliers. Implementation details: - Uses window points per segment. - Picks the window with the lowest stddev(values) . - Returns the maximum value inside that window. - details.window_points and details.stddev explain the chosen segment.","title":"Minimum standard deviation"},{"location":"15_analytics/#inverse-extrapolation-1z","text":"The inverse method fits a straight line to 1/Z versus 1/d and extrapolates to infinite distance. This is useful when the curve is still rising and remote earth is not clearly reached, but it can overestimate if the data range is short or noisy. Implementation details: - Fits a line to x = 1/d and y = 1/Z. - Extrapolates to x = 0 to get y = b, then Z_infinity = 1/b. - Returns result_distance_m = inf to indicate extrapolation. - Requires non-zero distances and values.","title":"Inverse extrapolation (1/Z)"},{"location":"15_analytics/#example-curve-minimum-standard-deviation","text":"This plot shows the minimum standard deviation window used to select a stable region of the distance curve.","title":"Example curve (minimum standard deviation)"},{"location":"15_analytics/#choosing-an-algorithm","text":"Use 62% when the geometry matches IEEE 80 assumptions (colinear probes, homogeneous soil) and you have a reliable injection distance. Use minimum gradient when the curve flattens clearly and noise is low. Use minimum standard deviation when the curve is noisy but you expect a stable plateau; increase window to smooth more. Use maximum when you intentionally search for and confirm the peak in the curve. Use inverse when remote earth is not fully reached; treat it as an extrapolation that can be conservative.","title":"Choosing an algorithm"},{"location":"15_analytics/#python-api-examples_1","text":"Scenario A: maximum method from groundmeas.db import connect_db from groundmeas.analytics import distance_profile_value connect_db ( \"groundmeas.db\" ) result = distance_profile_value ( 1 , algorithm = \"maximum\" ) print ( result [ \"result_value\" ], result [ \"result_distance_m\" ]) Scenario B: 62 percent method from groundmeas.db import connect_db from groundmeas.analytics import distance_profile_value connect_db ( \"groundmeas.db\" ) result = distance_profile_value ( 1 , algorithm = \"62_percent\" ) print ( result ) Scenario C: minimum standard deviation with a larger window from groundmeas.db import connect_db from groundmeas.analytics import distance_profile_value connect_db ( \"groundmeas.db\" ) result = distance_profile_value ( 1 , algorithm = \"minimum_stddev\" , window = 5 ) print ( result [ \"result_value\" ], result [ \"details\" ][ \"stddev\" ])","title":"Python API examples"},{"location":"15_analytics/#cli-examples_1","text":"Scenario A: minimum gradient gm-cli distance-profile 1 --type earthing_impedance --algorithm minimum_gradient Scenario B: inverse extrapolation gm-cli distance-profile 1 --type earthing_impedance --algorithm inverse","title":"CLI examples"},{"location":"15_analytics/#additional-notes_1","text":"The 62 percent method requires consistent distance_to_current_injection_m values; mixed values trigger a warning and the first value is used. Duplicate distances are deduplicated by choosing the point closest to linear interpolation between neighbors. For inverse, distances and values must be non-zero. Results depend on distance coverage; short or sparse curves can bias any reduction.","title":"Additional notes"},{"location":"15_analytics/#rho-f-model-fitting","text":"","title":"Rho-f model fitting"},{"location":"15_analytics/#physical-background_2","text":"The rho-f model links impedance to soil resistivity and frequency. It uses complex coefficients fitted from data. \\[ Z(\\rho, f) = k_1 \\cdot \\rho + (k_2 + j k_3) \\cdot f + (k_4 + j k_5) \\cdot \\rho \\cdot f \\]","title":"Physical background"},{"location":"15_analytics/#function-overview_2","text":"rho_f_model fits k1 to k5 from impedance and soil resistivity data.","title":"Function overview"},{"location":"15_analytics/#inputs-and-outputs_2","text":"Function Input Output Description rho_f_model measurement ids tuple Fit coefficients k1 to k5.","title":"Inputs and outputs"},{"location":"15_analytics/#general-workflow_2","text":"Ensure impedance data and soil resistivity data overlap in frequency. Call the fit function with one or more measurements. Validate coefficients by plotting model curves.","title":"General workflow"},{"location":"15_analytics/#python-api-examples_2","text":"Scenario A: single measurement from groundmeas.db import connect_db from groundmeas.analytics import rho_f_model connect_db ( \"groundmeas.db\" ) k1 , k2 , k3 , k4 , k5 = rho_f_model ([ 1 ]) print ( k1 , k2 , k3 , k4 , k5 ) Scenario B: combined fit from groundmeas.db import connect_db from groundmeas.analytics import rho_f_model connect_db ( \"groundmeas.db\" ) coeffs = rho_f_model ([ 1 , 2 , 3 ]) print ( coeffs )","title":"Python API examples"},{"location":"15_analytics/#cli-examples_2","text":"Scenario A: one measurement gm-cli rho-f-model 1 Scenario B: multiple measurements gm-cli rho-f-model 1 2 3 --json-out rho_f.json","title":"CLI examples"},{"location":"15_analytics/#additional-notes_2","text":"The fit requires real and imag impedance values plus soil resistivity values. If frequencies do not overlap, the fit may fail or return poor coefficients. Use plot-rho-f-model to inspect the fit visually.","title":"Additional notes"},{"location":"15_analytics/#voltage-touch-voltage-and-epr","text":"","title":"Voltage, touch voltage, and EPR"},{"location":"15_analytics/#physical-background_3","text":"Earth Potential Rise follows impedance and current. \\[ EPR = Z_E \\cdot I_E \\]","title":"Physical background"},{"location":"15_analytics/#function-overview_3","text":"voltage_vt_epr computes EPR and touch voltage summaries per measurement.","title":"Function overview"},{"location":"15_analytics/#inputs-and-outputs_3","text":"Function Input Output Description voltage_vt_epr measurement id or list, frequency dict EPR and touch voltage summary.","title":"Inputs and outputs"},{"location":"15_analytics/#general-workflow_3","text":"Ensure impedance and current items share the same frequency. Call the function with one or more measurements. Inspect EPR and voltage ranges.","title":"General workflow"},{"location":"15_analytics/#python-api-examples_3","text":"Scenario A: single measurement from groundmeas.db import connect_db from groundmeas.analytics import voltage_vt_epr connect_db ( \"groundmeas.db\" ) summary = voltage_vt_epr ( 1 , frequency = 50.0 ) print ( summary ) Scenario B: multiple measurements from groundmeas.db import connect_db from groundmeas.analytics import voltage_vt_epr connect_db ( \"groundmeas.db\" ) summary = voltage_vt_epr ([ 1 , 2 ], frequency = 50.0 ) print ( summary )","title":"Python API examples"},{"location":"15_analytics/#cli-examples_3","text":"Scenario A: one measurement gm-cli voltage-vt-epr 1 --frequency 50 Scenario B: multiple measurements gm-cli voltage-vt-epr 1 2 --frequency 50 --json-out vt.json","title":"CLI examples"},{"location":"15_analytics/#additional-notes_3","text":"If current or impedance data is missing, outputs will be incomplete. Use consistent units for current and impedance values.","title":"Additional notes"},{"location":"15_analytics/#shield-currents-and-split-factor","text":"","title":"Shield currents and split factor"},{"location":"15_analytics/#physical-background_4","text":"Earth fault current can split between cable shields and the local earthing system. The split factor quantifies that ratio.","title":"Physical background"},{"location":"15_analytics/#function-overview_4","text":"shield_currents_for_location lists shield current items for a location. calculate_split_factor computes the split factor and derived currents.","title":"Function overview"},{"location":"15_analytics/#inputs-and-outputs_4","text":"Function Input Output Description shield_currents_for_location location id, frequency list Shield current items. calculate_split_factor earth fault item id, shield item ids dict Split factor and current components.","title":"Inputs and outputs"},{"location":"15_analytics/#general-workflow_4","text":"Identify a location and available shield current items. Select the earth fault current item. Compute the split factor using selected shield currents.","title":"General workflow"},{"location":"15_analytics/#python-api-examples_4","text":"Scenario A: list shield currents from groundmeas.db import connect_db from groundmeas.analytics import shield_currents_for_location connect_db ( \"groundmeas.db\" ) shield_items = shield_currents_for_location ( location_id = 1 , frequency_hz = 50.0 ) print ( shield_items ) Scenario B: compute split factor from groundmeas.db import connect_db from groundmeas.analytics import calculate_split_factor connect_db ( \"groundmeas.db\" ) result = calculate_split_factor ( earth_fault_current_id = 100 , shield_current_ids = [ 201 , 202 ], ) print ( result )","title":"Python API examples"},{"location":"15_analytics/#cli-examples_4","text":"Scenario A: list shield currents gm-cli shield-currents 1 --frequency 50 Scenario B: split factor gm-cli calculate-split-factor --earth-fault-id 100 --shield-id 201 --shield-id 202","title":"CLI examples"},{"location":"15_analytics/#additional-notes_4","text":"Use consistent reference direction and frequency across shield current items. Mixed polar and rectangular values are supported, but avoid mixing units.","title":"Additional notes"},{"location":"15_analytics/#value-over-distance-mappings","text":"","title":"Value over distance mappings"},{"location":"15_analytics/#physical-background_5","text":"Not applicable. These functions provide distance-based mappings for plotting and QA.","title":"Physical background"},{"location":"15_analytics/#function-overview_5","text":"value_over_distance returns a simple distance to value map. value_over_distance_detailed returns distance, value, and frequency points.","title":"Function overview"},{"location":"15_analytics/#inputs-and-outputs_5","text":"Function Input Output Description value_over_distance measurement id or list, type dict Distance to value map. value_over_distance_detailed measurement id or list, type list or dict Detailed points with frequency.","title":"Inputs and outputs"},{"location":"15_analytics/#general-workflow_5","text":"Filter by measurement type (impedance, resistance, soil resistivity). Use the simple map for quick plots or checks. Use the detailed map when frequency separation matters.","title":"General workflow"},{"location":"15_analytics/#python-api-examples_5","text":"Scenario A: simple map from groundmeas.db import connect_db from groundmeas.analytics import value_over_distance connect_db ( \"groundmeas.db\" ) dist_map = value_over_distance ( 1 , measurement_type = \"earthing_impedance\" ) print ( dist_map ) Scenario B: detailed map from groundmeas.db import connect_db from groundmeas.analytics import value_over_distance_detailed connect_db ( \"groundmeas.db\" ) points = value_over_distance_detailed ([ 1 , 2 ], measurement_type = \"earthing_impedance\" ) print ( points [ 1 ][: 3 ])","title":"Python API examples"},{"location":"15_analytics/#cli-examples_5","text":"Scenario A: export and inspect gm-cli export-json out.json --measurement-id 1 Scenario B: list items for a specific type gm-cli list-items 1 --type earthing_impedance","title":"CLI examples"},{"location":"15_analytics/#additional-notes_5","text":"There is no direct CLI command for these functions; use export or list-items for equivalent data. Missing measurement_distance_m values are ignored.","title":"Additional notes"},{"location":"15_analytics/#soil-resistivity-profiles","text":"","title":"Soil resistivity profiles"},{"location":"15_analytics/#physical-background_6","text":"Wenner and Schlumberger arrays estimate apparent resistivity from field measurements. Wenner: \\[ \\rho_a = 2 \\pi a R \\] Schlumberger: \\[ \\rho_a = \\pi \\frac{AB^2 - MN^2}{4 MN} R \\]","title":"Physical background"},{"location":"15_analytics/#function-overview_6","text":"soil_resistivity_profile_detailed returns depth and spacing detail. soil_resistivity_profile returns depth to resistivity map. soil_resistivity_curve returns spacing to resistivity points.","title":"Function overview"},{"location":"15_analytics/#inputs-and-outputs_6","text":"Function Input Output Description soil_resistivity_profile_detailed measurement id, method, options list Detailed depth and spacing points. soil_resistivity_profile measurement id, method, options dict Depth to resistivity map. soil_resistivity_curve measurement id, method, options list Spacing to resistivity points.","title":"Inputs and outputs"},{"location":"15_analytics/#general-workflow_6","text":"Store soil resistivity or resistance values with spacing. Choose Wenner or Schlumberger method. Build a depth profile for QA. Use the spacing curve for inversion.","title":"General workflow"},{"location":"15_analytics/#python-api-examples_6","text":"Scenario A: Wenner resistivity values from groundmeas.db import connect_db from groundmeas.analytics import soil_resistivity_profile connect_db ( \"groundmeas.db\" ) profile = soil_resistivity_profile ( 2 , method = \"wenner\" ) print ( profile ) Scenario B: Schlumberger resistance values from groundmeas.db import connect_db from groundmeas.analytics import soil_resistivity_profile_detailed connect_db ( \"groundmeas.db\" ) profile = soil_resistivity_profile_detailed ( measurement_id = 3 , method = \"schlumberger\" , value_kind = \"resistance\" , ab_is_full = False , mn_is_full = False , ) print ( profile [: 3 ])","title":"Python API examples"},{"location":"15_analytics/#cli-examples_6","text":"Scenario A: Wenner profile gm-cli soil-profile 2 --method wenner Scenario B: Schlumberger profile with resistance values gm-cli soil-profile 3 --method schlumberger --value-kind resistance","title":"CLI examples"},{"location":"15_analytics/#additional-notes_6","text":"By default, Schlumberger spacing uses AB/2 and MN/2. Set ab_is_full or mn_is_full if you store full spacings. If units are missing, value_kind=auto assumes resistance.","title":"Additional notes"},{"location":"15_analytics/#layered-earth-model-and-inversion","text":"","title":"Layered earth model and inversion"},{"location":"15_analytics/#physical-background_7","text":"Layered earth models approximate soil resistivity changes with depth. Apparent resistivity curves are simulated with digital filters or an integral engine.","title":"Physical background"},{"location":"15_analytics/#function-overview_7","text":"LayeredEarthModel validates layer resistivities and thicknesses. multilayer_soil_model builds a layer table for reporting. layered_earth_forward simulates apparent resistivity for Wenner or Schlumberger. invert_layered_earth inverts spacing and apparent resistivity arrays. invert_soil_resistivity_layers inverts directly from stored soil items.","title":"Function overview"},{"location":"15_analytics/#inputs-and-outputs_7","text":"Function Input Output Description LayeredEarthModel rho_layers , thicknesses_m object Validated layered earth model. multilayer_soil_model rho_layers , thicknesses_m dict Layer table and parameters. layered_earth_forward spacings, model params list Simulated apparent resistivity curve. invert_layered_earth spacings, observed rho, params dict Fitted layers and misfit stats. invert_soil_resistivity_layers measurement id, params dict Invert from stored soil survey.","title":"Inputs and outputs"},{"location":"15_analytics/#general-workflow_7","text":"Choose 1 to 3 layers based on curve complexity. Set initial resistivities and thicknesses. Simulate the curve to sanity check the model. Run inversion and inspect misfit. Increase layer count only if needed.","title":"General workflow"},{"location":"15_analytics/#python-api-examples_7","text":"Scenario A: forward simulation from groundmeas.analytics import layered_earth_forward spacings = [ 1.0 , 2.0 , 4.0 , 8.0 ] resistivities = [ 100.0 , 30.0 ] thicknesses = [ 2.0 ] pred = layered_earth_forward ( spacings_m = spacings , rho_layers = resistivities , thicknesses_m = thicknesses , method = \"wenner\" , ) print ( pred ) Scenario B: inversion from stored survey from groundmeas.db import connect_db from groundmeas.analytics import invert_soil_resistivity_layers connect_db ( \"groundmeas.db\" ) inv = invert_soil_resistivity_layers ( measurement_id = 2 , method = \"wenner\" , layers = 2 , initial_rho = [ 120.0 , 35.0 ], initial_thicknesses = [ 2.5 ], max_iter = 40 , damping = 0.1 , ) print ( inv [ \"rho_layers\" ], inv [ \"thicknesses_m\" ], inv [ \"misfit\" ])","title":"Python API examples"},{"location":"15_analytics/#cli-examples_7","text":"Scenario A: simulate a model gm-cli soil-model --rho 100 --rho 30 --thickness 2 \\ --method wenner --spacing 1 --spacing 2 --spacing 4 Scenario B: invert a model gm-cli soil-inversion 2 --layers 2 --method wenner \\ --initial-rho 120 --initial-rho 35 \\ --initial-thickness 2 .5","title":"CLI examples"},{"location":"15_analytics/#additional-notes_7","text":"The filter forward engine assumes MN is small compared to AB for Schlumberger. Use forward=integral when MN is not negligible (requires SciPy). Inversion can be sensitive to initial guesses; start with 1 layer and add complexity gradually. Use backend=\"mlx\" on Apple hardware if MLX is installed for speed.","title":"Additional notes"},{"location":"16_dashboard/","text":"Dashboard This tutorial shows how to use the Streamlit dashboard for interactive analysis and plotting. Physical background Not applicable. The dashboard is a user interface for the analytics already described in earlier tutorials. Function overview The dashboard uses plot functions such as plot_imp_over_f_plotly and plot_soil_inversion_plotly . It calls analytics functions such as invert_soil_resistivity_layers and soil_resistivity_curve . Inputs and outputs Function Input Output Description plot_imp_over_f_plotly measurement ids Plotly figure Impedance vs frequency plot. plot_soil_inversion_plotly measurement id, inversion options Plotly figure Observed vs fitted resistivity plot. invert_soil_resistivity_layers measurement id, layers dict Fitted layered model and misfit. soil_resistivity_curve measurement id, method list Spacing vs apparent resistivity points. General workflow Scenario A: compare impedance across sites Launch the dashboard. Filter by asset type in the sidebar. Select multiple measurements on the map. Open the Impedance vs Frequency tab and generate the plot. Scenario B: soil inversion and model inspection Select a soil survey measurement. Open the Soil Simulation tab to test a layered model. Open the Soil Inversion tab and run the inversion. Review the fitted curve and layer table. Python API examples Scenario A: compare impedance across sites from groundmeas.db import connect_db from groundmeas.visualization.vis_plotly import plot_imp_over_f_plotly connect_db ( \"groundmeas.db\" ) fig = plot_imp_over_f_plotly ([ 1 , 2 , 3 ]) fig . show () Scenario B: soil inversion and model inspection from groundmeas.db import connect_db from groundmeas.visualization.vis_plotly import plot_soil_inversion_plotly connect_db ( \"groundmeas.db\" ) fig = plot_soil_inversion_plotly ( measurement_id = 2 , method = \"wenner\" , layers = 2 , initial_rho = [ 120.0 , 35.0 ], initial_thicknesses = [ 2.5 ], ) fig . show () CLI examples Scenario A: compare impedance across sites gm-cli plot-impedance 1 2 3 --out plots/imp_over_f.png Scenario B: soil inversion and model inspection gm-cli soil-inversion 2 --layers 2 --method wenner \\ --initial-rho 120 --initial-rho 35 \\ --initial-thickness 2 .5 gm-cli plot-soil-inversion 2 --layers 2 --out plots/soil_inv.png Additional notes Large datasets can slow down the dashboard; use filters to reduce selection. If the dashboard shows missing data warnings, verify item types and frequencies. If soil inversion fails, check spacing values and units for soil resistivity items.","title":"Dashboard"},{"location":"16_dashboard/#dashboard","text":"This tutorial shows how to use the Streamlit dashboard for interactive analysis and plotting.","title":"Dashboard"},{"location":"16_dashboard/#physical-background","text":"Not applicable. The dashboard is a user interface for the analytics already described in earlier tutorials.","title":"Physical background"},{"location":"16_dashboard/#function-overview","text":"The dashboard uses plot functions such as plot_imp_over_f_plotly and plot_soil_inversion_plotly . It calls analytics functions such as invert_soil_resistivity_layers and soil_resistivity_curve .","title":"Function overview"},{"location":"16_dashboard/#inputs-and-outputs","text":"Function Input Output Description plot_imp_over_f_plotly measurement ids Plotly figure Impedance vs frequency plot. plot_soil_inversion_plotly measurement id, inversion options Plotly figure Observed vs fitted resistivity plot. invert_soil_resistivity_layers measurement id, layers dict Fitted layered model and misfit. soil_resistivity_curve measurement id, method list Spacing vs apparent resistivity points.","title":"Inputs and outputs"},{"location":"16_dashboard/#general-workflow","text":"","title":"General workflow"},{"location":"16_dashboard/#scenario-a-compare-impedance-across-sites","text":"Launch the dashboard. Filter by asset type in the sidebar. Select multiple measurements on the map. Open the Impedance vs Frequency tab and generate the plot.","title":"Scenario A: compare impedance across sites"},{"location":"16_dashboard/#scenario-b-soil-inversion-and-model-inspection","text":"Select a soil survey measurement. Open the Soil Simulation tab to test a layered model. Open the Soil Inversion tab and run the inversion. Review the fitted curve and layer table.","title":"Scenario B: soil inversion and model inspection"},{"location":"16_dashboard/#python-api-examples","text":"","title":"Python API examples"},{"location":"16_dashboard/#scenario-a-compare-impedance-across-sites_1","text":"from groundmeas.db import connect_db from groundmeas.visualization.vis_plotly import plot_imp_over_f_plotly connect_db ( \"groundmeas.db\" ) fig = plot_imp_over_f_plotly ([ 1 , 2 , 3 ]) fig . show ()","title":"Scenario A: compare impedance across sites"},{"location":"16_dashboard/#scenario-b-soil-inversion-and-model-inspection_1","text":"from groundmeas.db import connect_db from groundmeas.visualization.vis_plotly import plot_soil_inversion_plotly connect_db ( \"groundmeas.db\" ) fig = plot_soil_inversion_plotly ( measurement_id = 2 , method = \"wenner\" , layers = 2 , initial_rho = [ 120.0 , 35.0 ], initial_thicknesses = [ 2.5 ], ) fig . show ()","title":"Scenario B: soil inversion and model inspection"},{"location":"16_dashboard/#cli-examples","text":"","title":"CLI examples"},{"location":"16_dashboard/#scenario-a-compare-impedance-across-sites_2","text":"gm-cli plot-impedance 1 2 3 --out plots/imp_over_f.png","title":"Scenario A: compare impedance across sites"},{"location":"16_dashboard/#scenario-b-soil-inversion-and-model-inspection_2","text":"gm-cli soil-inversion 2 --layers 2 --method wenner \\ --initial-rho 120 --initial-rho 35 \\ --initial-thickness 2 .5 gm-cli plot-soil-inversion 2 --layers 2 --out plots/soil_inv.png","title":"Scenario B: soil inversion and model inspection"},{"location":"16_dashboard/#additional-notes","text":"Large datasets can slow down the dashboard; use filters to reduce selection. If the dashboard shows missing data warnings, verify item types and frequencies. If soil inversion fails, check spacing values and units for soil resistivity items.","title":"Additional notes"},{"location":"20_ref_intro/","text":"Reference overview Use the reference section for exact signatures, arguments, and behavior. Every entry lists the function or command name, inputs, outputs, and a short description. 21_ref_api.md : Python API reference for the public functions in groundmeas . 22_ref_cli.md : CLI reference for every gm-cli command. Tip: All database operations require groundmeas.db.connect_db(path) once per process. The CLI resolves the path automatically; Python code must call it explicitly.","title":"Overview"},{"location":"20_ref_intro/#reference-overview","text":"Use the reference section for exact signatures, arguments, and behavior. Every entry lists the function or command name, inputs, outputs, and a short description. 21_ref_api.md : Python API reference for the public functions in groundmeas . 22_ref_cli.md : CLI reference for every gm-cli command. Tip: All database operations require groundmeas.db.connect_db(path) once per process. The CLI resolves the path automatically; Python code must call it explicitly.","title":"Reference overview"},{"location":"21_ref_api/","text":"API Reference All database-backed functions require groundmeas.db.connect_db(path) once per process. Database (groundmeas.db) function input output description connect_db path , echo none Initialize or open the SQLite database. create_measurement measurement dict measurement id Create a measurement, optionally with nested location. create_item item dict, measurement_id item id Create a measurement item. read_measurements where clause list of measurements, list of ids Read measurements with nested items and location. read_measurements_by filters list of measurements, list of ids Read measurements with suffix operators ( __lt , __in , etc). read_items_by filters list of items, list of ids Read items with suffix operators. update_measurement measurement id, updates bool Update measurement and optional location. update_item item id, updates bool Update a measurement item. delete_measurement measurement id bool Delete a measurement and its items. delete_item item id bool Delete a single item. Analytics (groundmeas.analytics) function input output description impedance_over_frequency measurement id or list dict Frequency to impedance map. real_imag_over_frequency measurement id or list dict Frequency to real and imag map. distance_profile_value measurement id, algorithm, window dict Reduce distance profile to one value. value_over_distance measurement id or list, type dict Distance to value map. value_over_distance_detailed measurement id or list, type list or dict Distance, value, frequency points. rho_f_model measurement ids tuple Rho-f coefficients k1 to k5. voltage_vt_epr measurement id or list, frequency dict EPR and touch voltage summary. shield_currents_for_location location id, frequency list Shield current items. calculate_split_factor earth fault item id, shield item ids dict Split factor and current components. soil_resistivity_profile measurement id, method, value_kind dict Depth to apparent resistivity map. soil_resistivity_profile_detailed measurement id, method, value_kind list Detailed depth and spacing points. soil_resistivity_curve measurement id, method, value_kind list Spacing to apparent resistivity points. multilayer_soil_model rho_layers , thicknesses_m dict Layer table from resistivities and thicknesses. layered_earth_forward spacings, model params list Simulated apparent resistivity. invert_layered_earth spacings, observed rho, model params dict Fitted layers and misfit stats. invert_soil_resistivity_layers measurement id, model params dict Invert from stored soil items. Export (groundmeas.export) function input output description export_measurements_to_json path , filters none Write measurements and items to JSON. export_measurements_to_csv path , filters none Write measurements to CSV with items as JSON. export_measurements_to_xml path , filters none Write measurements and items to XML. OCR Import (groundmeas.vision_import) function input output description import_items_from_images images dir, measurement id, options dict OCR import of items from images. Matplotlib plots (groundmeas.plots) function input output description plot_imp_over_f measurement id or list, normalize figure Impedance vs frequency plot. plot_rho_f_model measurement ids, rho_f, rho figure Rho-f model plot. plot_voltage_vt_epr measurement ids, frequency figure EPR and touch voltage plot. plot_value_over_distance measurement id or list, type figure Value vs distance plot. plot_soil_model rho_layers , thicknesses_m , max depth figure Layered soil model plot. plot_soil_inversion measurement id, inversion options figure Observed vs fitted resistivity plot. Plotly plots (groundmeas.vis_plotly) function input output description plot_imp_over_f_plotly measurement id or list, normalize figure Interactive impedance plot. plot_rho_f_model_plotly measurement ids, rho_f, rho figure Interactive rho-f plot. plot_voltage_vt_epr_plotly measurement ids, frequency figure Interactive EPR plot. plot_value_over_distance_plotly measurement id or list, options figure Interactive distance plot. plot_soil_model_plotly rho_layers , thicknesses_m , max depth figure Interactive soil model plot. plot_soil_inversion_plotly measurement id, inversion options figure Interactive inversion plot. Maps (groundmeas.map_vis) function input output description generate_map measurements, output file, open_browser none Generate a Folium map.","title":"API"},{"location":"21_ref_api/#api-reference","text":"All database-backed functions require groundmeas.db.connect_db(path) once per process.","title":"API Reference"},{"location":"21_ref_api/#database-groundmeasdb","text":"function input output description connect_db path , echo none Initialize or open the SQLite database. create_measurement measurement dict measurement id Create a measurement, optionally with nested location. create_item item dict, measurement_id item id Create a measurement item. read_measurements where clause list of measurements, list of ids Read measurements with nested items and location. read_measurements_by filters list of measurements, list of ids Read measurements with suffix operators ( __lt , __in , etc). read_items_by filters list of items, list of ids Read items with suffix operators. update_measurement measurement id, updates bool Update measurement and optional location. update_item item id, updates bool Update a measurement item. delete_measurement measurement id bool Delete a measurement and its items. delete_item item id bool Delete a single item.","title":"Database (groundmeas.db)"},{"location":"21_ref_api/#analytics-groundmeasanalytics","text":"function input output description impedance_over_frequency measurement id or list dict Frequency to impedance map. real_imag_over_frequency measurement id or list dict Frequency to real and imag map. distance_profile_value measurement id, algorithm, window dict Reduce distance profile to one value. value_over_distance measurement id or list, type dict Distance to value map. value_over_distance_detailed measurement id or list, type list or dict Distance, value, frequency points. rho_f_model measurement ids tuple Rho-f coefficients k1 to k5. voltage_vt_epr measurement id or list, frequency dict EPR and touch voltage summary. shield_currents_for_location location id, frequency list Shield current items. calculate_split_factor earth fault item id, shield item ids dict Split factor and current components. soil_resistivity_profile measurement id, method, value_kind dict Depth to apparent resistivity map. soil_resistivity_profile_detailed measurement id, method, value_kind list Detailed depth and spacing points. soil_resistivity_curve measurement id, method, value_kind list Spacing to apparent resistivity points. multilayer_soil_model rho_layers , thicknesses_m dict Layer table from resistivities and thicknesses. layered_earth_forward spacings, model params list Simulated apparent resistivity. invert_layered_earth spacings, observed rho, model params dict Fitted layers and misfit stats. invert_soil_resistivity_layers measurement id, model params dict Invert from stored soil items.","title":"Analytics (groundmeas.analytics)"},{"location":"21_ref_api/#export-groundmeasexport","text":"function input output description export_measurements_to_json path , filters none Write measurements and items to JSON. export_measurements_to_csv path , filters none Write measurements to CSV with items as JSON. export_measurements_to_xml path , filters none Write measurements and items to XML.","title":"Export (groundmeas.export)"},{"location":"21_ref_api/#ocr-import-groundmeasvision_import","text":"function input output description import_items_from_images images dir, measurement id, options dict OCR import of items from images.","title":"OCR Import (groundmeas.vision_import)"},{"location":"21_ref_api/#matplotlib-plots-groundmeasplots","text":"function input output description plot_imp_over_f measurement id or list, normalize figure Impedance vs frequency plot. plot_rho_f_model measurement ids, rho_f, rho figure Rho-f model plot. plot_voltage_vt_epr measurement ids, frequency figure EPR and touch voltage plot. plot_value_over_distance measurement id or list, type figure Value vs distance plot. plot_soil_model rho_layers , thicknesses_m , max depth figure Layered soil model plot. plot_soil_inversion measurement id, inversion options figure Observed vs fitted resistivity plot.","title":"Matplotlib plots (groundmeas.plots)"},{"location":"21_ref_api/#plotly-plots-groundmeasvis_plotly","text":"function input output description plot_imp_over_f_plotly measurement id or list, normalize figure Interactive impedance plot. plot_rho_f_model_plotly measurement ids, rho_f, rho figure Interactive rho-f plot. plot_voltage_vt_epr_plotly measurement ids, frequency figure Interactive EPR plot. plot_value_over_distance_plotly measurement id or list, options figure Interactive distance plot. plot_soil_model_plotly rho_layers , thicknesses_m , max depth figure Interactive soil model plot. plot_soil_inversion_plotly measurement id, inversion options figure Interactive inversion plot.","title":"Plotly plots (groundmeas.vis_plotly)"},{"location":"21_ref_api/#maps-groundmeasmap_vis","text":"function input output description generate_map measurements, output file, open_browser none Generate a Folium map.","title":"Maps (groundmeas.map_vis)"},{"location":"22_ref_cli/","text":"CLI Reference (gm-cli) All commands accept --db PATH or GROUNDMEAS_DB . Default order is GROUNDMEAS_DB , ~/.config/groundmeas/config.json , then ./groundmeas.db . Data management function input output description add-measurement prompts for location, method, asset, metadata console summary Interactive measurement creation. list-measurements none console table List measurements with basic metadata. list-items MEAS_ID , --type console table List items for a measurement. add-item MEAS_ID , prompts console summary Interactive item creation. edit-measurement MEAS_ID , prompts console summary Interactive measurement edit. edit-item ITEM_ID , prompts console summary Interactive item edit. delete-measurement MEAS_ID , --yes/-y console confirmation Delete measurement and items. delete-item ITEM_ID , --yes/-y console confirmation Delete one item. Import and export function input output description import-json PATH console summary Import measurements from JSON file or folder. export-json OUT.json , --measurement-id/-m JSON file Export measurements to JSON. import-from-images MEAS_ID , IMAGES_DIR , options console or JSON OCR import from images. Analytics function input output description distance-profile MEAS_ID , --type , --algorithm , --window console or JSON Reduce a distance profile. impedance-over-frequency MEAS_ID... console or JSON Frequency to impedance map. real-imag-over-frequency MEAS_ID... console or JSON Frequency to real and imag map. rho-f-model MEAS_ID... console or JSON Fit rho-f coefficients. voltage-vt-epr MEAS_ID... , --frequency console or JSON EPR and touch voltage summary. shield-currents LOCATION_ID , --frequency console or JSON List shield currents. calculate-split-factor --earth-fault-id , --shield-id console or JSON Split factor and currents. soil-profile MEAS_ID , options console or JSON Depth-resistivity profile. soil-model --rho , --thickness , options console or JSON Layered model and optional simulation. soil-inversion MEAS_ID , options console or JSON Invert layered model. Plotting function input output description plot-impedance MEAS_ID... , --normalize , --out image file Impedance vs frequency plot. plot-rho-f-model MEAS_ID... , --rho-f , --rho , --out image file Rho-f model plot. plot-voltage-vt-epr MEAS_ID... , --frequency , --out image file EPR and touch voltage plot. plot-soil-model --rho , --thickness , --max-depth , --out image file Layered soil model plot. plot-soil-inversion MEAS_ID , options, --out image file Observed vs fitted resistivity plot. Maps and dashboard function input output description map --measurement-id/-m , --out , --open-browser HTML file Generate a Folium map. dashboard none Streamlit app Launch the dashboard. Configuration function input output description set-default-db PATH console confirmation Store default DB path.","title":"CLI"},{"location":"22_ref_cli/#cli-reference-gm-cli","text":"All commands accept --db PATH or GROUNDMEAS_DB . Default order is GROUNDMEAS_DB , ~/.config/groundmeas/config.json , then ./groundmeas.db .","title":"CLI Reference (gm-cli)"},{"location":"22_ref_cli/#data-management","text":"function input output description add-measurement prompts for location, method, asset, metadata console summary Interactive measurement creation. list-measurements none console table List measurements with basic metadata. list-items MEAS_ID , --type console table List items for a measurement. add-item MEAS_ID , prompts console summary Interactive item creation. edit-measurement MEAS_ID , prompts console summary Interactive measurement edit. edit-item ITEM_ID , prompts console summary Interactive item edit. delete-measurement MEAS_ID , --yes/-y console confirmation Delete measurement and items. delete-item ITEM_ID , --yes/-y console confirmation Delete one item.","title":"Data management"},{"location":"22_ref_cli/#import-and-export","text":"function input output description import-json PATH console summary Import measurements from JSON file or folder. export-json OUT.json , --measurement-id/-m JSON file Export measurements to JSON. import-from-images MEAS_ID , IMAGES_DIR , options console or JSON OCR import from images.","title":"Import and export"},{"location":"22_ref_cli/#analytics","text":"function input output description distance-profile MEAS_ID , --type , --algorithm , --window console or JSON Reduce a distance profile. impedance-over-frequency MEAS_ID... console or JSON Frequency to impedance map. real-imag-over-frequency MEAS_ID... console or JSON Frequency to real and imag map. rho-f-model MEAS_ID... console or JSON Fit rho-f coefficients. voltage-vt-epr MEAS_ID... , --frequency console or JSON EPR and touch voltage summary. shield-currents LOCATION_ID , --frequency console or JSON List shield currents. calculate-split-factor --earth-fault-id , --shield-id console or JSON Split factor and currents. soil-profile MEAS_ID , options console or JSON Depth-resistivity profile. soil-model --rho , --thickness , options console or JSON Layered model and optional simulation. soil-inversion MEAS_ID , options console or JSON Invert layered model.","title":"Analytics"},{"location":"22_ref_cli/#plotting","text":"function input output description plot-impedance MEAS_ID... , --normalize , --out image file Impedance vs frequency plot. plot-rho-f-model MEAS_ID... , --rho-f , --rho , --out image file Rho-f model plot. plot-voltage-vt-epr MEAS_ID... , --frequency , --out image file EPR and touch voltage plot. plot-soil-model --rho , --thickness , --max-depth , --out image file Layered soil model plot. plot-soil-inversion MEAS_ID , options, --out image file Observed vs fitted resistivity plot.","title":"Plotting"},{"location":"22_ref_cli/#maps-and-dashboard","text":"function input output description map --measurement-id/-m , --out , --open-browser HTML file Generate a Folium map. dashboard none Streamlit app Launch the dashboard.","title":"Maps and dashboard"},{"location":"22_ref_cli/#configuration","text":"function input output description set-default-db PATH console confirmation Store default DB path.","title":"Configuration"},{"location":"99_contributing/","text":"Contributing to groundmeas We welcome contributions. Follow these steps to set up a local development environment. Development setup Clone the repository: git clone https://github.com/Ce1ectric/groundmeas.git cd groundmeas Install dependencies (Poetry): poetry install Activate the environment: poetry shell Running tests We use pytest . pytest Building documentation We use MkDocs with the Read the Docs theme and mkdocstrings. Install doc dependencies: poetry add -D mkdocs mkdocstrings [ python ] Serve documentation locally: mkdocs serve Build the static site: mkdocs build Release process Use the included script to release a new version: python scripts/release.py","title":"Contributing"},{"location":"99_contributing/#contributing-to-groundmeas","text":"We welcome contributions. Follow these steps to set up a local development environment.","title":"Contributing to groundmeas"},{"location":"99_contributing/#development-setup","text":"Clone the repository: git clone https://github.com/Ce1ectric/groundmeas.git cd groundmeas Install dependencies (Poetry): poetry install Activate the environment: poetry shell","title":"Development setup"},{"location":"99_contributing/#running-tests","text":"We use pytest . pytest","title":"Running tests"},{"location":"99_contributing/#building-documentation","text":"We use MkDocs with the Read the Docs theme and mkdocstrings. Install doc dependencies: poetry add -D mkdocs mkdocstrings [ python ] Serve documentation locally: mkdocs serve Build the static site: mkdocs build","title":"Building documentation"},{"location":"99_contributing/#release-process","text":"Use the included script to release a new version: python scripts/release.py","title":"Release process"}]}